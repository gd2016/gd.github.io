<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>pdf文件在线预览以及标记</title>
    <link href="/2022/09/24/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-pdf/"/>
    <url>/2022/09/24/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-pdf/</url>
    
    <content type="html"><![CDATA[<p>本篇介绍使用 <strong><strong>pdfjs-dist</strong></strong> 来预览pdf文件，以及高亮pdf文件内容。</p><span id="more"></span><p>使用<strong>pdfjs-dist</strong>前， 需要指定worker脚本的位置 <strong>pdf.worker.min.js</strong> 采用Web Worker技术实现异步和多线程处理，提供性能防止阻塞主线程。当需要解析或渲染大型PDF文档时，繁重的工作（如解析PDF数据结构、生成页面图像等）会在独立的Web Worker线程中进行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div<br>    ref=&quot;paneRef&quot;<br>    class=&quot;w-full h-full flex-1 bg-gray-100 rounded-md relative&quot;<br>  &gt;<br>    &lt;div<br>      v-if=&quot;loading&quot;<br>      class=&quot;w-full h-full top-0 left-0 flex justify-center items-center z-10 bg-[rgba(255,255,255,0.6)] dark:bg-blur-shared&quot;<br>    &gt;<br>      &lt;span class=&quot;loading loading-infinity loading-lg&quot;&gt;&lt;/span&gt;<br>    &lt;/div&gt;<br>    &lt;template v-else&gt;<br>      &lt;div<br>        v-for=&quot;(item, i) in pageNum&quot;<br>        :key=&quot;item + i&quot;<br>        ref=&quot;boxRef&quot;<br>        class=&quot;bg-[#fff] relative border-b-2 overflow-hidden&quot;<br>      &gt;<br>        &lt;div ref=&quot;wrapRef&quot; class=&quot;canvasWrapper&quot;&gt;&lt;/div&gt;<br>        &lt;div<br>          ref=&quot;txtRef&quot;<br>          class=&quot;textLayer absolute inset-0 overflow-hidden opacity-25 origin-top-left z-20 leading-none&quot;<br>        &gt;&lt;/div&gt;<br>      &lt;/div&gt;<br>    &lt;/template&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import * as pdfjsLib from &quot;pdfjs-dist&quot;;<br>import &#123; ref, onMounted, nextTick &#125; from &quot;vue&quot;;<br><br>let pdf;<br>const loading = ref(false);<br>const pageNum = ref();<br>async function loadFile() &#123;<br>  loading.value = true;<br>  pdfjsLib.GlobalWorkerOptions.workerSrc = &quot;/pdf.worker.min.js&quot;;<br>  const pdfDocument = await pdfjsLib.getDocument(&quot;/test.doc&quot;).promise;<br>  loading.value = false;<br>  pdf = pdfDocument;<br>  pageNum.value = new Array(pdf.numPages).fill(1);<br>  nextTick(() =&gt; &#123;<br>    draw(1);<br>  &#125;);<br>&#125;<br><br>const wrapRef = ref();<br>const boxRef = ref();<br>const paneRef = ref();<br>const scaleRect = ref(0);<br>const txtRef = ref();<br>const draw = async (index) =&gt; &#123;<br>  const page = await pdf.getPage(index);<br>  const viewport = page.getViewport(&#123; scale: 1 &#125;);<br>  const scale = paneRef.value.offsetWidth / viewport.width;<br>  scaleRect.value = scale;<br>  const canvas = document.createElement(&quot;canvas&quot;);<br>  const context = canvas.getContext(&quot;2d&quot;);<br>  canvas.width = Math.floor(viewport.width * scale);<br>  canvas.height = Math.floor(viewport.height * scale);<br>  canvas.style.width = `$&#123;Math.floor(viewport.width * scale)&#125;px`;<br>  canvas.style.height = `$&#123;Math.floor(viewport.height * scale)&#125;px`;<br>  wrapRef.value[index - 1].append(canvas);<br><br>  // 渲染页面<br>  page.render(&#123;<br>    canvasContext: context,<br>    viewport: page.getViewport(&#123; scale &#125;),<br>  &#125;);<br><br>  const warpDom = boxRef.value[index - 1];<br>  warpDom.style.setProperty(<br>    &quot;--scale-factor&quot;,<br>    paneRef.value.offsetWidth / viewport.width<br>  );<br><br>  //渲染textlayer，让内容可编辑<br>  page.getTextContent().then((textContent) =&gt; &#123;<br>    return pdfjsLib.renderTextLayer(&#123;<br>      textContentSource: textContent,<br>      container: txtRef.value[index - 1],<br>      viewport: page.getViewport(&#123; scale &#125;),<br>      textDivs: [],<br>    &#125;);<br>  &#125;);<br><br>  if (index &lt; pdf.numPages) &#123;<br>    await draw(index + 1);<br>  &#125;<br>&#125;;<br><br>onMounted(loadFile);<br>&lt;/script&gt;<br><br>&lt;style&gt;<br>.textLayer :is(span, br) &#123;<br>  color: transparent;<br>  position: absolute;<br>  white-space: pre;<br>  cursor: text;<br>  transform-origin: 0% 0%;<br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><p>可编辑的pdf预览功能就实现了，预览pdf比较简单。</p><p>我们试着加个新功能，渲染高亮区域。在canvasWrapper后加入svg，通过绝对定位画出高亮区域。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template v-else&gt;<br>  &lt;div<br>    v-for=&quot;(item, i) in pageNum&quot;<br>    :key=&quot;item + i&quot;<br>    ref=&quot;boxRef&quot;<br>    class=&quot;bg-[#fff] relative border-b-2 overflow-hidden&quot;<br>  &gt;<br>    &lt;div ref=&quot;wrapRef&quot; class=&quot;canvasWrapper&quot;&gt;&lt;/div&gt;<br>    &lt;svg v-if=&quot;pageLabels[i + 1]&quot; class=&quot;absolute top-0 w-full h-full&quot;&gt;<br>      &lt;rect<br>        v-for=&quot;item in pageLabels[i + 1]&quot;<br>        :x=&quot;item.bbox[0] * scale&quot;<br>        :y=&quot;item.bbox[1] * scale&quot;<br>        :width=&quot;(item.bbox[2] - item.bbox[0]) * scale&quot;<br>        :height=&quot;(item.bbox[3] - item.bbox[1]) * scale&quot;<br>        :style=&quot;&#123;<br>          fill: &#x27;rgba(255, 236, 61, 0.2)&#x27;,<br>          strokeWidth: 1,<br>          stroke: &#x27;#ffec3d&#x27;,<br>        &#125;&quot;<br>      /&gt;<br>    &lt;/svg&gt;<br>    &lt;div<br>      ref=&quot;txtRef&quot;<br>      class=&quot;textLayer absolute inset-0 overflow-hidden opacity-25 origin-top-left z-20 leading-none&quot;<br>    &gt;&lt;/div&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br>&lt;script setup&gt;<br><br>const pageLabels = ref(&#123;<br>  //1为页码，表示高亮区域在第一页， bbox是个长方形渲染区域坐标值，<br>  1: [<br>    &#123;<br>      bbox: [187, 106, 407, 132],<br>    &#125;,<br>  ],<br>&#125;);<br><br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>其中bbox是高亮区域的坐标值，这个值可以由AI来计算得出。</p>]]></content>
    
    
    <categories>
      
      <category>三方库使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>如何规划一个优雅且严谨的service（pro）</title>
    <link href="/2022/01/18/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-service-pro/"/>
    <url>/2022/01/18/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-service-pro/</url>
    
    <content type="html"><![CDATA[<p>接上一篇serivce服务，这次我们写个更加严谨健壮的service</p><span id="more"></span><p>上次说的service只是最普通的例子，还有更严谨的写法，不过要搭配ts，有了类型推断，我们调用service的时候，可以知道参数类型，返回类型，让我们的service更健壮</p><p>定义一个APISerive类，负责请求方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//request.ts</span><br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br>axios.<span class="hljs-property">interceptors</span>.<span class="hljs-property">response</span>.<span class="hljs-title function_">use</span>(<br>  <span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> res = response.<span class="hljs-property">data</span><br>    <span class="hljs-keyword">if</span> (res.<span class="hljs-property">code</span> == <span class="hljs-number">200</span>) &#123;<br>      <span class="hljs-keyword">return</span> res<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(res)<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(error)<br>  &#125;<br>)<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">instance</span> = axios.<span class="hljs-title function_">create</span>(&#123;<br>      <span class="hljs-attr">baseURL</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">baseUrl</span><br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-title function_">request</span>(<span class="hljs-params">method, url, data = &#123;&#125;, config = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">instance</span>(&#123;<br>      method,<br>      url,<br>      data,<br>      ...config<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">url, config = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, url, &#123;&#125;, config)<br>  &#125;<br><br>  <span class="hljs-title function_">post</span>(<span class="hljs-params">url, data, config = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;POST&#x27;</span>, url, data, config)<br>  &#125;<br><br>  <span class="hljs-title function_">put</span>(<span class="hljs-params">url, data, config = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;PUT&#x27;</span>, url, data, config)<br>  &#125;<br><br>  <span class="hljs-title function_">patch</span>(<span class="hljs-params">url, data, config = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;PATCH&#x27;</span>, url, data, config)<br>  &#125;<br><br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">url, data = &#123;&#125;, config = &#123;&#125;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">request</span>(<span class="hljs-string">&#x27;DELETE&#x27;</span>, url, data, config)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApiService</span>()<br></code></pre></td></tr></table></figure><p>定义 Repository 类，负责请求接口、地址</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//CommentRepository.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ApiService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/services/request&#x27;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">APICommentRepository</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly request = ApiService</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">list</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">exampleId</span>: number): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommentItem</span>[]&gt; &#123;<br>        <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/projects/<span class="hljs-subst">$&#123;projectId&#125;</span>/comments?example=<span class="hljs-subst">$&#123;exampleId&#125;</span>&amp;limit=100`</span><br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">get</span>(url)<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span><br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">update</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">item</span>: <span class="hljs-title class_">CommentItem</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommentItem</span>&gt; &#123;<br>        <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/projects/<span class="hljs-subst">$&#123;projectId&#125;</span>/comments/<span class="hljs-subst">$&#123;item.id&#125;</span>`</span><br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">put</span>(url, item.<span class="hljs-title function_">toObject</span>())<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span><br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">delete</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">commentId</span>: number): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; &#123;<br>        <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/projects/<span class="hljs-subst">$&#123;projectId&#125;</span>/comments/<span class="hljs-subst">$&#123;commentId&#125;</span>`</span><br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">delete</span>(url)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">APICommentRepository</span><br></code></pre></td></tr></table></figure><p>定义实体类，负责转化数据类型、过滤前端用不到的字段信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">CommentRepository</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/repository&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentApplicationService</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly repository: CommentRepository</span>) &#123;&#125;<br><br>  public <span class="hljs-keyword">async</span> <span class="hljs-title function_">list</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">docId</span>: number): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommentReadDTO</span>[]&gt; &#123;<br>    <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">repository</span>.<span class="hljs-title function_">list</span>(projectId, docId)<br>    <span class="hljs-keyword">return</span> items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommentReadDTO</span>(item))<br>  &#125;<br><br>  public <span class="hljs-title function_">update</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">item</span>: <span class="hljs-title class_">CommentReadDTO</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommentItem</span>&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">repository</span>.<span class="hljs-title function_">update</span>(projectId, item)<br>  &#125;<br><br>  public <span class="hljs-title function_">delete</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">item</span>: <span class="hljs-title class_">CommentReadDTO</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-keyword">void</span>&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">repository</span>.<span class="hljs-title function_">delete</span>(projectId, item.<span class="hljs-property">id</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>不知道大家发现没有，上述service多了一个CommentReadDTO类，DTO后端同学都很熟悉，实体类。其实前端也可以模拟一个DTO。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//commentData.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentReadDTO</span> &#123;<br>  <span class="hljs-attr">id</span>: number<br>  <span class="hljs-attr">user</span>: number<br>  <span class="hljs-attr">username</span>: string<br>  <span class="hljs-attr">example</span>: number<br>  <span class="hljs-attr">text</span>: string<br>  <span class="hljs-attr">createdAt</span>: string<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">item: CommentItem</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span> = item.<span class="hljs-property">id</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span> = item.<span class="hljs-property">user</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span> = item.<span class="hljs-property">username</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span> = item.<span class="hljs-property">example</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = item.<span class="hljs-property">text</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdAt</span> = item.<span class="hljs-property">createdAt</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>后端往往会返回一些多余的字段，但是前端用不到，所以前端可以自己定义一个DTO，把用不到的字段过滤掉。保证后续删字段，维护代码更方便。</p><p>DTO与Repository结合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//service/index.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CommentApplicationService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;/services/commentApplicationService&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">APICommentRepository</span>  <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;~/repositories/comment/apiCommentRepository&#x27;</span> <br><br><span class="hljs-keyword">const</span> commentRepository = <span class="hljs-keyword">new</span> <span class="hljs-title class_">APICommentRepository</span>()<br><span class="hljs-keyword">const</span> comment = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommentApplicationService</span>(commentRepository)<br><span class="hljs-keyword">export</span> interface <span class="hljs-title class_">Services</span> &#123;<br>    <span class="hljs-attr">comment</span>: <span class="hljs-title class_">CommentApplicationService</span><br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">services</span>: <span class="hljs-title class_">Services</span>  = &#123;<br>    comment<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> services<br></code></pre></td></tr></table></figure><p>逻辑代码中调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">comments</span>: [] <span class="hljs-keyword">as</span> <span class="hljs-title class_">CommentReadDTO</span>[]<br>        &#125;<br>    &#125;,<br>    <span class="hljs-attr">methods</span>: &#123;<br>      <span class="hljs-keyword">async</span> <span class="hljs-title function_">list</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">comments</span> = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$services</span>.<span class="hljs-property">comment</span>.<span class="hljs-title function_">list</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">exampleId</span>)<br>      &#125;,<br>      <br>      <span class="hljs-keyword">async</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">item: CommentReadDTO</span>) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$services</span>.<span class="hljs-property">comment</span>.<span class="hljs-title function_">delete</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>, item)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">list</span>()<br>      &#125;,<br>      <span class="hljs-keyword">async</span> <span class="hljs-title function_">update</span>(<span class="hljs-params">item: CommentReadDTO</span>) &#123;<br>        <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$services</span>.<span class="hljs-property">comment</span>.<span class="hljs-title function_">update</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$route</span>.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>, item)<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">list</span>()<br>      &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一套完整的service链路就这样完成了。</p><p>不知道大家有没有遇到过这样一种情况，后端的字段命名规范是下划线，但是前端是驼峰，这样就需要一个新的工具库 class-transformer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CommentItem</span> &#123;<br>  <span class="hljs-attr">id</span>: number<br>  <span class="hljs-attr">user</span>: number<br>  <span class="hljs-attr">username</span>: string<br>  <span class="hljs-attr">example</span>: number<br>  <span class="hljs-attr">text</span>: string<br><br>  @<span class="hljs-title class_">Expose</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;created_at&#x27;</span> &#125;)<br>  <span class="hljs-attr">createdAt</span>: string<br><br>  <span class="hljs-title function_">toObject</span>(): <span class="hljs-title class_">Object</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">id</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">id</span>,<br>      <span class="hljs-attr">user</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">user</span>,<br>      <span class="hljs-attr">username</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">username</span>,<br>      <span class="hljs-attr">document</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">example</span>,<br>      <span class="hljs-attr">text</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span>,<br>      <span class="hljs-attr">created_at</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">createdAt</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Expose是装饰器，告诉class-transformer，这个字段在转换成对象的时候，使用这个字段的别名。 例如接收到的created_at&#x3D;&gt;createdAt</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; plainToInstance &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;class-transformer&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">APICommentRepository</span>&#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">private readonly request = ApiService</span>) &#123;&#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">list</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">exampleId</span>: number): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommentItem</span>[]&gt; &#123;<br>        <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/projects/<span class="hljs-subst">$&#123;projectId&#125;</span>`</span><br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">get</span>(url)<br>        <span class="hljs-keyword">return</span> response.<span class="hljs-property">data</span>.<span class="hljs-property">results</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item: any</span>) =&gt;</span> <span class="hljs-title function_">plainToInstance</span>(<span class="hljs-title class_">CommentItem</span>, item))<br>    &#125;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-title function_">update</span>(<span class="hljs-attr">projectId</span>: string, <span class="hljs-attr">item</span>: <span class="hljs-title class_">CommentItem</span>): <span class="hljs-title class_">Promise</span>&lt;<span class="hljs-title class_">CommentItem</span>&gt; &#123;<br>        <span class="hljs-keyword">const</span> url = <span class="hljs-string">`/projects/<span class="hljs-subst">$&#123;projectId&#125;</span>`</span><br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">request</span>.<span class="hljs-title function_">put</span>(url, item.<span class="hljs-title function_">toObject</span>())<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">plainToInstance</span>(<span class="hljs-title class_">CommentItem</span>, response.<span class="hljs-property">data</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过api <code>plainToInstance</code> 来实现对象的转化。 另外定义了toObject方法，因为在修改的时候，后端接收的字段也是下划线的命名规范</p>]]></content>
    
    
    <categories>
      
      <category>代码整洁之道</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>前端如何管理一个优雅的service服务</title>
    <link href="/2022/01/17/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-service/"/>
    <url>/2022/01/17/%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93-service/</url>
    
    <content type="html"><![CDATA[<p>关于怎么管理service的写法，以及 <code>service</code> 的 <code>generator</code> 的使用。</p><span id="more"></span><p>不知道大家有没有发现，每次在调用接口的时候，都要去 <code>import</code> 一个 <code>service</code> 我们的service一般是这样的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//service.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">queryPath</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">request</span>(&#123;<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/api/graph/query/path&#x27;</span>,<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    data<br>  &#125;)<br><br></code></pre></td></tr></table></figure><p>然后调用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; queryPath &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/service&#x27;</span> <br><span class="hljs-title function_">queryPath</span>(data, database)<br></code></pre></td></tr></table></figure><p>传统的的serice写法是这样的，麻烦的点在于每次都要引入，且当一个文件的function太多的时候，往往不知道 queryPath 到底是逻辑方法还是接口调用，于是，我决定写一个 <code>service</code> 的 <code>generator</code>。</p><p>定义个service类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GraphService</span> &#123;<br>    <span class="hljs-title function_">queryPath</span>(<span class="hljs-params">data</span>)&#123;<br>        <span class="hljs-keyword">return</span> axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/graph/query/path&#x27;</span>, data)<br>    &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GraphService</span>()<br><br></code></pre></td></tr></table></figure><p>调用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">GraphService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/service/graph&#x27;</span><br><span class="hljs-title class_">GraphService</span>.<span class="hljs-title function_">queryPath</span>(data)<br></code></pre></td></tr></table></figure><p>这样是不是就很明显的知道这是一个接口请求方法，vscode 会自动提示，而且可以 <code>ctrl + click</code> 直接跳转到定义处，是不是很方便？当然只是简单的例子，可以定义多个service统一在index.js里导出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//service/index.js</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">GraphService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./graph&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">UserService</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./user&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>    <span class="hljs-attr">graph</span>: <span class="hljs-title class_">GraphService</span>,<br>    <span class="hljs-attr">user</span>: <span class="hljs-title class_">UserService</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> service <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/service&#x27;</span><br>service.<span class="hljs-property">graph</span>.<span class="hljs-title function_">queryPath</span>(data)<br>service.<span class="hljs-property">user</span>.<span class="hljs-title function_">queryUser</span>(data)<br></code></pre></td></tr></table></figure><p>如果你是使用的vue2，可以把service挂载到vue的原型上，这样就可以直接在vue的实例中使用 <code>this.$service.graph.queryPath(data)</code><br>如果你是使用的vue3，可能还是需要 <code>import service from &#39;@/api/service&#39;</code></p>]]></content>
    
    
    <categories>
      
      <category>代码整洁之道</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>script标签有哪些属性</title>
    <link href="/2021/04/20/%E5%9F%BA%E7%A1%80-script/"/>
    <url>/2021/04/20/%E5%9F%BA%E7%A1%80-script/</url>
    
    <content type="html"><![CDATA[<p>看看script标签可以有哪些属性及属性值</p><span id="more"></span><h2 id="src"><a href="#src" class="headerlink" title="src"></a>src</h2><p>这个不用多说，就是指向script脚本的引用地址</p><h2 id="type"><a href="#type" class="headerlink" title="type"></a>type</h2><p>该属性定义script元素包含或src引用的脚本语言。属性的值为MIME类型;</p><ul><li>text&#x2F;javascript（默认）</li><li>text&#x2F;ecmascript</li><li>application&#x2F;javascript</li><li>application&#x2F;ecmascript</li><li>module</li></ul><p>着重注意一下module这个值，当type为module时代码会被当做JavaScript模块处理，且默认为defer</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>&lt;script type=<span class="hljs-string">&quot;module&quot;</span>&gt;<br>  <span class="hljs-keyword">import</span> &#123;addTextToBody&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span>;<br>  <span class="hljs-title function_">addTextToBody</span>(<span class="hljs-string">&#x27;Modules are pretty cool.&#x27;</span>);<br>&lt;/script&gt;<br><br></code></pre></td></tr></table></figure><h3 id="async"><a href="#async" class="headerlink" title="async"></a>async</h3><p>该属性指示浏览器是否在允许的情况下异步执行该脚本。该属性对于没有src属性的脚本不起作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;file.js&quot;</span> <span class="hljs-keyword">async</span>&gt;&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>等同于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&quot;file.js&quot;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br><span class="hljs-comment">//从脚本中创建的脚本默认为异步。</span><br></code></pre></td></tr></table></figure><p>浏览器支持： chrome，firfox，safari，IE10+。</p><h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>这个属性被设定用来通知浏览器“该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行”。如果无src，则不起作用。</p><p>不管这段脚本放在html的何处(即使head中)，都会等待dom解析完成后再去加载。</p><p>如果将script标签放在整个html文件的最后，那就不需要defer了，画蛇添足。</p><h3 id="async和defer的区别"><a href="#async和defer的区别" class="headerlink" title="async和defer的区别"></a>async和defer的区别</h3><p>defer要等到浏览器整个页面渲染完成后，才开始执行；<br>async是在渲染html时发现脚本已经异步下载完，就去执行，执行完了，继续往下渲染html，即只要脚本加载完就执行；</p><h3 id="普通script解析顺序"><a href="#普通script解析顺序" class="headerlink" title="普通script解析顺序"></a>普通script解析顺序</h3><p>文档解析时，遇到普通script脚本会停止页面的解析进行下载，资源的下载是在解析时进行的，如果后面的script先下载完成，但是如果前面的没有下载并执行，后面的是不会执行的，必须按照顺序一个一个执行</p><p>遇到defer的脚本时，文档解析跟脚本加载是并列进行的，会在后台下载script，等到所有的script加载完毕，然后按顺序执行，执行完毕后出发DOMContentLoaded事件</p><p>async脚本在加载完毕后执行且不计入DOMContentLoaded统计，也就是有可能在DOMContentLoaded之前就执行也可能在DOMContentLoaded之后。</p><h3 id="async和defer的应用场景"><a href="#async和defer的应用场景" class="headerlink" title="async和defer的应用场景"></a>async和defer的应用场景</h3><p>如果脚本代码依赖于页面的dom元素（须等待文档解析完毕），或者被其他脚本依赖</p><p>如： 1. 评论框， 2.代码语法高亮，3.polyfill.js  则使用defer</p><p>脚本不关心文档的解析，也不会产生其他脚本依赖。 如：百度统计。  用async</p><h2 id="crossorigin"><a href="#crossorigin" class="headerlink" title="crossorigin"></a>crossorigin</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>src是跨站脚本，出现错误时，是没法获取到准确的错误信息，只能打印出script error（浏览器控制台可以打印， 但是无法在js脚本中获取捕获到）</p><p>所以添加crossorigin属性来获取跨站文件的错误信息。</p><p>服务器必须设置允许： access-control-allow-origin: *</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script<br>      src=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/vue@2.6.10/dist/vue.js&quot;</span><br>      crossorigin=<span class="hljs-string">&quot;anonymous&quot;</span>&gt;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>crossorigin的值为:<br>anonymous 采用普通方式设置对此元素的CORS请求<br>use-credentials 采用凭证的方式设置对此元素的CORS请求</p><p>目前只有IE浏览器不支持</p><h2 id="integrity"><a href="#integrity" class="headerlink" title="integrity"></a>integrity</h2>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>vue原理</title>
    <link href="/2020/11/22/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-vue/"/>
    <url>/2020/11/22/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-vue/</url>
    
    <content type="html"><![CDATA[<p>vue大致原理</p><span id="more"></span><h3 id="new-Vue的过程"><a href="#new-Vue的过程" class="headerlink" title="new Vue的过程"></a>new Vue的过程</h3><ul><li>合并配置</li><li>生命周期</li><li>事件</li><li>渲染</li><li>初始化配置（data&#x2F;computed等）</li></ul><p>$mount方法调用的是mountComponent函数，实例化了一个渲染Watcher，回调中再调用<strong>updateComponent</strong>方法，在此方法中调用 vm._render 方法先生成虚拟 Node，最终调用 vm._update 更新 DOM。 watcher的作用是在初始化的时候执行回调函数，vm实例中检测的数据发生变化的时候执行回调函数；</p><h3 id="虚拟dom"><a href="#虚拟dom" class="headerlink" title="虚拟dom"></a>虚拟dom</h3><p>虚拟dom没有原生dom那么多属性方法，所以创建它的开销就小了很多，<strong>virtualdom</strong> 到 真实dom经过了以下过程： <strong>create</strong>、<strong>diff</strong>、<strong>patch</strong></p><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>初始化、数据更新的时候调用update</p><p>核心是调用了<strong>vm.<strong>patch</strong></strong> 方法 web生成了dom节点  ssr是生成了html字符串 </p><p>dom树节点的插入顺序是<strong>先子后父</strong></p><p>new Vue ➜ init ➜ $mount ➜ compile ➜ render ➜ vnode ➜ patch ➜ dom</p><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h3><p>render函数里面h参数： 其中当tag为组件时调用了createComponent， 将组件转化成虚拟dom</p><ul><li>构造子类构造函数</li><li>安装组件钩子函数 </li><li>实例化VNode</li></ul><p>Vue.extend（global-api&#x2F;extend.js）构造一个vue子类，子类其实就是一个组件，使用原型链把对象转换一个继承Vue的构造器 名叫 Sub并返回<br>Sub扩展了属性，opions&#x2F;API等，并对配置中的props和computed做初始化<br>缓存Sub，避免多次调用Vue.extend对同一个组件重复构造</p><p><strong>Vue.extend</strong> 可以用来写全局组件，比如消息通知类的组件</p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>patch完成组件的渲染工作，patch在createComponent将组件转化为VNode后，会调用createElm把VNode转化成真正的dom节点</p><ul><li>createComponent：递归实现深度遍历整个VNode树，先子后父的方式插入dom树</li><li>最终根节点VNode转化为dom后挂载到#app的节点上，且挂载元素不能是html或body</li><li>patch流程： createComponent-&gt;组件初始化-&gt;子组件render-&gt;组件patch</li></ul><h3 id="合并配置"><a href="#合并配置" class="headerlink" title="合并配置"></a>合并配置</h3><p>写的组件会调用Vue.extend生成一个组件类，组件类实例化的时候就会合并配置： mixin。extend（options）。对象组件配置</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>beforeCreate ➜ created ➜ beforeMount ➜ mounted ➜ beforeUpdate ➜ updated ➜ beforeDestroy ➜ destroyed</li><li>在keep-alive组件中多了activated ➜ deactivated</li><li>生命周期是维护的一个数组，可能有多个函数（默认的配置和用户写的配置）</li><li>父子组件生命周期执行顺序： 父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子bedoreCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</li><li>更新： 父beforeUpdate ➜ 子beforeUpdate ➜ 子updated ➜ 父updated</li><li>销毁： 父beforeDestroy ➜ 子beforeDestroy ➜ 子destroyed ➜ 父destroyed</li></ul><h4 id="beforeCreate-created"><a href="#beforeCreate-created" class="headerlink" title="beforeCreate &amp; created"></a>beforeCreate &amp; created</h4><ul><li>beforeCreate调用在实例化&amp;初始化（props,data）等前， created在初始化后</li><li>beforeCreate无法访问this实例,data数据等，created可以访问</li><li>调用顺序：先父后子</li><li>使用场景：在created中获取后端数据</li></ul><h4 id="beforeMount-mounted"><a href="#beforeMount-mounted" class="headerlink" title="beforeMount &amp; mounted"></a>beforeMount &amp; mounted</h4><ul><li>调用在DOM挂在前后</li><li>beforeMount也是先父后子，mounted是先子后父</li><li>使用场景： mounted中可操作dom；访问ref</li></ul><h4 id="beforeUpdate-updated"><a href="#beforeUpdate-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h4><p>更新dom前后 </p><h4 id="beforeDestroy-destroyed"><a href="#beforeDestroy-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h4><ul><li>实例销毁前后</li><li>类似parentNode.removeChild，在parent的$children销毁自身，删除watcher</li><li>使用场景：beforeDestroy可解除绑定的事件监听</li></ul><p>activated &amp; deactivated</p><p>调用在keep-alive激活后和即将离开激活后</p><h4 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a>注册组件</h4><ul><li>全局注册Vue.component(tagName, options)，挂载到Vue.options.components上，所有组件均可访问</li><li>局部注册，components属性</li><li>解析模板遇到组件时，优先解析局部组件，在找全局组件</li></ul><h4 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h4><p>异步组件有4种状态： loading、resolve、reject、timeout， 实现的本质是进行了2次渲染<br>0 delay的高级异步组件是第一次直接渲染成loading组件， 其他组件第一次渲染生成注释节点<!-- -->，当异步组件获取成功后，再通过forceRender强制重新渲染</p><p>有3种异步组件：</p><ol><li>普通函数异步组件: 通过resove回调处理</li><li>Promise 异步组件：promise.then处理</li><li>高级异步组件: 增加loading、error、delay、timeout等，处理了加载占位、错误处理、超时时间等;</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Vue</span>.<span class="hljs-title function_">component</span>(<br>  <span class="hljs-string">&#x27;async-webpack-example&#x27;</span>,<br>  <span class="hljs-comment">// 这个动态导入会返回一个 `Promise` 对象。</span><br>  <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./my-async-component&#x27;</span>)<br>)<br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123; <span class="hljs-comment">//局部注册</span><br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-string">&#x27;my-component&#x27;</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./my-async-component&#x27;</span>)<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure><h2 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h2><h3 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h3><p>利用 <strong>Object.defineProperty</strong> 给数据添加 <strong>getter&#x2F;setter</strong>  getter做的事情是<strong>依赖收集</strong>， setter是 <strong>派发更新</strong><br>使用的设计模式： <strong>发布订阅模式（观察者模式）</strong></p><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><ul><li>vm._render()过程中，就触发所有数据的getter进行依赖收集</li><li>响应式对象的getter里触发dep.depend做依赖收集，将获取属性的地方全部加入订阅者列表中，数据变化后，遍历列表通知订阅者更新</li></ul><h3 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h3><ul><li>数据变化时触发setter，在收集依赖时所有订阅的观察者（watcher），触发update更新过程</li><li>更新过程利用队列做了进一步优化，在nextTick后执行所有watcher的run，再执行他们的回调函数</li><li>通过setter触发更新，这里引入队列的优化，他不会每次数据改变都触发更新，而是添加到队列里，在nextTick后一次执行</li><li>对队列做了排序： <ul><li>组件的更新前父到子，因为创建的过程是先父到子</li><li>用户的自定义 watcher 要优先于渲染 watcher 执行；因为用户自定义 watcher 是在渲染 watcher 之前创建的。</li><li>如果一个组件在父组件的 watcher 执行期间被销毁，那么它对应的 watcher 执行都可以被跳过，所以父组件的 watcher 应该先执行。</li></ul></li></ul><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p>可以在数据修改触发dom更新后调用</p><h3 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h3><ul><li>给对象添加新的属性不会被<strong>Object.defineProperty</strong>监测到，通过Vue.set方法手动告诉vue收集这个依赖并且派发更新。</li><li>vue不能直接检测到数组项的<strong>赋值和直接修改长度</strong>的，但是可以监测到splice 等方法的修改，原因在于<ul><li>赋值：无法给数组设置defineProperty，可通过Vue.set实现对数组项的修改；</li><li>通过数组方法修改：vue在Observer类中单独对数组做了处理，对数组对能增加数组长度的 3 个方法重写push、unshift、sueplice，将方法原有逻辑执行完，再手动把新添加的值变成一个响应式对象，并且派发更新。</li></ul></li><li>对象属性的删除可通过Vue.del方法，确保触发更新视图</li></ul><h3 id="计算属性computd-VS-侦听属性watch"><a href="#计算属性computd-VS-侦听属性watch" class="headerlink" title="计算属性computd VS 侦听属性watch"></a>计算属性computd VS 侦听属性watch</h3><p>计算属性computed触发的情况：</p><ul><li>主动访问： 触发getter函数，执行用户返回的计算结果。只有返回值发生变化的时候才触发渲染更新（缓存，依赖变化时才执行）</li><li>依赖属性更新： 计算属性成为依赖变量的订阅者，依赖变量发生改变则触发计算属性重新计算。</li><li>计算属性有 lazy 和 active两种模式，active模式依赖更新立即计算，lazy模式依赖变化仅设置this.dirty &#x3D; true，等访问计算属性时再重新计算，并加入缓存。</li></ul><p>监听属性</p><ul><li>监听属性相当于主动订阅了属性的变化，属性发生变化时执行回调函数</li><li>监听属性的watcher执行优先级高于渲染watcher；</li><li>deep 设置为 true 用于监听对象内部值的变化</li><li>immediate 设置为 true 将立即以表达式的当前值触发回调</li></ul><p>本质上侦听属性也是基于 Watcher 实现的，它是一个 user watcher。</p><p>计算属性 vs 监听属性 从应用场景看:<br>  计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；<br>  侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑（例如执行异步或开销较大的操作）</p><p><strong>watcher的 4 种类型：deep、user、computed、sync</strong></p><p>deep：可以监听到对象属性的属性的修改变化，递归遍历对象所有属性，订阅所有子孙属性的变化（设置方法deep: true）；<br>user：watch里面添加的侦听属性<br>computed：computed里面添加的监听<br>sync：属性变化后同步执行更新，不会加入缓冲队列在 nextTick 后执行。（设置方法immediate: true）</p><p><strong>计算属性 vs 方法</strong></p><ul><li>缓存： computed 可以的，methods 不能；只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行；调用方法将总会再次执行函数；</li><li>延时计算： 计算属性主要对响应式属性的依赖，没有响应式依赖不会自动更新：如这样只会计算一次computed: {now: ()&#x3D;&gt;Date.now()}<br>值得注意的是计算属性可以通过返回一个函数形成闭包来实现传参；</li></ul><h3 id="组件更新（diff）"><a href="#组件更新（diff）" class="headerlink" title="组件更新（diff）"></a>组件更新（diff）</h3><p>diff策略：</p><ul><li>web ui跨层级的移动操作少，忽略不计，因此只进行同层比较</li><li>如果父节点不同，放弃对子节点的比较，直接删除旧节点然后添加新节点重新渲染</li><li>如果子节点有变化，Virtual DOM不会计算变化的是什么，而是重新渲染</li><li>同级多个节点可通过唯一的key对比异同</li></ul><p>diff流程：</p><ul><li>新旧节点不同： 创建新节点-&gt;更新父占位符节点-&gt;删除旧节点</li><li>相同且没有子节点：不变</li><li>相同且都有子节点：遍历子节点同级比较，做移动、删除、增加等操作</li></ul><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>template 模板编译成 render 函数</p><p>vue有两种编译模式：</p><ul><li>运行时编译：在运行时才做模版编译（ Runtime + Compiler ）</li><li>打包编译：借助 webpack 的 vue-loader 事先把模板编译成 render函数（Runtime only ）</li></ul><p>三步操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">// 解析模板字符串生成 AST</span><br><span class="hljs-keyword">const</span> ast = <span class="hljs-title function_">parse</span>(template.<span class="hljs-title function_">trim</span>(), options)<br><span class="hljs-comment">// 优化语法树</span><br><span class="hljs-title function_">optimize</span>(ast, options)<br><span class="hljs-comment">// 生成代码</span><br><span class="hljs-keyword">const</span> code = <span class="hljs-title function_">generate</span>(ast, options)<br><br></code></pre></td></tr></table></figure><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>把template转化成AST语法树，一种JavaScript对象形式来描述整个html模板，也是用正则表达式来解析模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> attribute = <span class="hljs-regexp">/^\s*([^\s&quot;&#x27;&lt;&gt;\/=]+)(?:\s*(=)\s*(?:&quot;([^&quot;]*)&quot;+|&#x27;([^&#x27;]*)&#x27;+|([^\s&quot;&#x27;=&lt;&gt;`]+)))?/</span><br><span class="hljs-keyword">const</span> ncname = <span class="hljs-string">&#x27;[a-zA-Z_][\\w\\-\\.]*&#x27;</span> <br><span class="hljs-keyword">const</span> qnameCapture = <span class="hljs-string">`((?:<span class="hljs-subst">$&#123;ncname&#125;</span>\\:)?<span class="hljs-subst">$&#123;ncname&#125;</span>)`</span><br><span class="hljs-keyword">const</span> startTagOpen = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;<span class="hljs-subst">$&#123;qnameCapture&#125;</span>`</span>) <span class="hljs-comment">// 开始标签打开</span><br><span class="hljs-keyword">const</span> startTagClose = <span class="hljs-regexp">/^\s*(\/?)&gt;/</span> <span class="hljs-comment">// 开始标签关闭</span><br><span class="hljs-keyword">const</span> endTag = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`^&lt;\\/<span class="hljs-subst">$&#123;qnameCapture&#125;</span>[^&gt;]*&gt;`</span>) <span class="hljs-comment">// 标签结束</span><br><span class="hljs-keyword">const</span> doctype = <span class="hljs-regexp">/^&lt;!DOCTYPE [^&gt;]+&gt;/i</span> <span class="hljs-comment">// 文档类型节点</span><br><span class="hljs-keyword">const</span> comment = <span class="hljs-regexp">/^&lt;!\--/</span> <span class="hljs-comment">// 注释节点</span><br><span class="hljs-keyword">const</span> conditionalComment = <span class="hljs-regexp">/^&lt;!\[/</span><br><br></code></pre></td></tr></table></figure><h3 id="optmize"><a href="#optmize" class="headerlink" title="optmize"></a>optmize</h3><p>优化AST树的原因：处理响应式、标记静态节点、处理指令等</p><p>静态节点判断方法：</p><ul><li>如果是表达式，就是非静态；如果是纯文本，就是静态；</li><li>普通元素用了 <strong>v-pre</strong> 指令，是静态;</li><li>普通元素满足下面所有条件则是静态：<br>没有使用 v-if、v-for<br>没有使用其它指令（不包括 v-once）<br>非内置组件，是平台保留的标签<br>非带有 v-for 的 template 标签的直接子节点，节点的所有属性的 key 都满足静态 key</li></ul><p>如果是普通元素非静态节点，则遍历它的所有 children，递归执行静态节点的标记，子节点有不是静态的情况，则它的父节点也为非静态。</p><p><strong>标记静态根</strong>：缓存节点，优化diff过程，来减少操作dom</p><h3 id="generate-codegen"><a href="#generate-codegen" class="headerlink" title="generate  codegen"></a>generate  codegen</h3><p>将AST语法树转化成可执行的render函数，主要处理AST的以下属性，变成render函数的写法：</p><ul><li>static静态节点</li><li>once只渲染一次的节点</li><li>for处理循环</li><li>if处理条件渲染</li><li>children递归处理树状结构</li><li>slot处理插槽</li><li>处理组件或者原生dom标签</li></ul><h2 id="vue-router路由注册"><a href="#vue-router路由注册" class="headerlink" title="vue-router路由注册"></a>vue-router路由注册</h2><ul><li>插件通过Vue.use方法来实现注册，实际上是运行插件的install方法</li><li>Vue-Router安装最重要的一步就是利用 Vue.mixin 去把 beforeCreate 和 destroyed 钩子函数注入到每一个组件中，达到router的钩子能顺利调用的目的</li><li>通过在Vue.prototype原型上添加方法的方式来让用户访问到方法，使用defineProperty设置只读可避免被用户手动篡改。</li><li>注册全局组件 <router-link> 和 <router-view></li></ul><h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>vue有了数据响应式，为何还要diff？</p><p>React通过setState知道有变化了，但不知道哪里变化了，所以需要通过diff层层找出变化的地方并更新dom，React从一开始就不知道到底是哪发生了变化,只是知道「有变化了」,然后再进行比较暴力的Diff操作查找「哪发生变化了」，另外一个代表就是Angular的脏检查操作。</p><p>Vue已经可以通过响应式系统知道哪里发生了变化，但是所有变化都通过响应式会创建大量Watcher，极其消耗性能，因此vue采用的方式是通过响应式系统知道哪个组件发生了变化，然后在组件内部使用diff。这样的中粒度策略，即不会产生大量的Watcher，也使diff的节点减少了，一举两得</p>]]></content>
    
    
    <categories>
      
      <category>三方库使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>umi-ui 源码解析</title>
    <link href="/2020/10/16/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-umi-ui/"/>
    <url>/2020/10/16/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-umi-ui/</url>
    
    <content type="html"><![CDATA[<p>在umi基础上扩展的umi-ui插件</p><span id="more"></span><h2 id="umi-ui启动顺序"><a href="#umi-ui启动顺序" class="headerlink" title="umi-ui启动顺序"></a>umi-ui启动顺序</h2><ol><li>node .&#x2F;scripts&#x2F;ui.js</li><li><strong>打包</strong>3个ui插件： plugin-ui-blocks&#x2F;plugin-ui-tasks&#x2F;preset-ui</li><li>运行ui界面  ui&#x2F;web</li><li>客户端： 运行界面 packages&#x2F;ui&#x2F;web 执行app.ts  render方法初始化<ol><li>获取三方静态资源</li><li>初始化socket</li><li>获取项目列表</li><li>如果是task路由 则表示打开一个项目</li><li>初始化ui插件的api一系列方法，用于拓展ui第三方插件</li></ol></li><li>服务端： packages&#x2F;preset-ui&#x2F;src&#x2F;index.ts  引用了ui、task、blocks等插件 依次执行</li></ol><h2 id="umi插件机制"><a href="#umi插件机制" class="headerlink" title="umi插件机制"></a>umi插件机制</h2><ol><li>preset-ui 作为umi的插件运行 (umi-ui暂时只能伴随项目启动，还没有做到全局启动)</li><li>创建UmiUI实例（初始化socket和一系列针对web传过来的socket请求的处理）</li><li>加载task、block插件</li></ol><h2 id="umi-ui插件"><a href="#umi-ui插件" class="headerlink" title="umi-ui插件"></a>umi-ui插件</h2><p>UI 插件与普通 Umi 的插件实际是一样的原理。</p><p>只是比一般的 Umi 插件，多使用两个 API：</p><ul><li><code>api.addUIPlugin</code> 用于加载 ui 的 umd 包</li><li><code>api.onUISocket</code> 为前端 ui 提供服务端接口</li></ul><h2 id="如何开放接口供第三方插件插件使用"><a href="#如何开放接口供第三方插件插件使用" class="headerlink" title="如何开放接口供第三方插件插件使用"></a>如何开放接口供第三方插件插件使用</h2><ol><li>umi会调用插件的入口文件，通过传参的形式</li></ol><h2 id="ui-blocks插件"><a href="#ui-blocks插件" class="headerlink" title="ui-blocks插件"></a>ui-blocks插件</h2><ol><li>通过window.postMessage通信</li><li>通过babel插件，来注入一系列代码</li></ol><h2 id="用到的-package"><a href="#用到的-package" class="headerlink" title="用到的 package"></a>用到的 package</h2><ol><li>yeoman-generator  脚手架生成工具</li><li>resolve-from  解析文件路径</li><li>binary-mirror-config 获取国内镜像配置</li><li>cross-spawn   同node spawn 只是做了跨平台兼容</li><li>execa  同node exec</li><li>glob   根据路径规则获取匹配到的所有文件路径</li><li>sylvanas 将ts文件转化为js文件</li><li>sort-package-json 可以删除掉空行并且排序</li><li>prettier 格式化文件</li><li>mem-fs mem-fs-editor 拷贝文件</li><li>babel系列包</li><li>mustache</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li>lerna + yarn workspaces 的 monorepos项目</li><li>babel插件编写</li></ol><h2 id="项目启动流程及插件加载调用"><a href="#项目启动流程及插件加载调用" class="headerlink" title="项目启动流程及插件加载调用"></a>项目启动流程及插件加载调用</h2><ol><li>项目本身暂时是作为umi插件启动，后期作者会改为全局包</li><li>入口文件：preset-ui(依次调用) <ol><li>registerMethods.js注册umi-ui新方法（addUIPlugin&#x2F;ui界面, onUISocket&#x2F;serve服务端:主要处理websocket请求）</li><li>启动umi-ui主界面及服务(开发调试socket服务在3000， 页面在8002会跨域，所以通过routes&#x2F;common代理)</li><li>addBubble  umi-ui辅助工具</li><li>引入ui插件</li></ol></li><li>加载插件（tasks、blocks）addUiPlugin(解析ui插件文件)) onUISocket（websocket处理服务）</li><li>UI界面是调用插件的? 获取插件umd文件，通过eval执行并传递PluginAPI参数</li></ol><h2 id="task插件"><a href="#task插件" class="headerlink" title="task插件"></a>task插件</h2><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ol><li>安装umi-ui生成器</li><li>安装依赖，进入create-umi通过generator生成项目</li><li>根据模板package.json删除多余的文件，或者ts文件转化为js文件</li></ol><h3 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h3><ol><li>使用了dva的数据流，调用exec执行任务，向后端发送callRemote请求</li><li>后端接受请求并执行项目scripts脚本</li><li>terminal通信：<ol><li>通过runCommand返回的子进程对象获取log</li><li>触发监听事件：TaskEventType.STD_OUT_DATA</li><li>send（websocket）方法发送log到客户端</li><li>由于发送日志的type在serve没有声明，客户端是通过监听listenRemote获取到log</li><li>获取到客户端terminal元素写入log</li></ol></li></ol><h2 id="blocks插件"><a href="#blocks插件" class="headerlink" title="blocks插件"></a>blocks插件</h2><h3 id="插入资产（babel插件）"><a href="#插入资产（babel插件）" class="headerlink" title="插入资产（babel插件）"></a>插入资产（babel插件）</h3><ol><li>注入GUmiUIFlag全局组件（babel插件）</li><li>插入区块<ol><li>解析 url &#x3D;&gt; git 地址</li><li>如果不存在，则 git clone 到本地临时目录</li><li>git pull 更新到最新分支</li><li>依赖处理，处理依赖冲突、依赖安装、依赖写入</li><li>写区块到项目目录中（nodeJs copy 到目标路径）</li><li>写路由改文件内容（babel插件）</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>原理探究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>nothing</title>
    <link href="/2020/04/26/%E5%9F%BA%E7%A1%80-nothing/"/>
    <url>/2020/04/26/%E5%9F%BA%E7%A1%80-nothing/</url>
    
    <content type="html"><![CDATA[<p>工作突然遇到的特殊技巧</p><span id="more"></span><h2 id="symbol的应用场景"><a href="#symbol的应用场景" class="headerlink" title="symbol的应用场景"></a>symbol的应用场景</h2><p>symbol是ES6新特性，类似标识唯一性的ID，每个Symbol的实例都是唯一的。</p><p>场景1： 可以作为class的私有属性或者对象的私有属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PROP_NAME</span> = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-keyword">let</span> obj = &#123;<br>  [<span class="hljs-variable constant_">PROP_NAME</span>]: <span class="hljs-string">&quot;一斤代码&quot;</span> <span class="hljs-comment">//</span><br>&#125;<br></code></pre></td></tr></table></figure><p>只能通过obj[PROP_NAME]或者 Object.getOwnPropertySymbols(obj)拿到<br>JSON.stringify(obj)、Object.keys(obj)等一系列获取方法都是获取不到obj的key值的</p><p>场景2： 使用Symbol来替代常量</p><h2 id="什么叫暂时性死区"><a href="#什么叫暂时性死区" class="headerlink" title="什么叫暂时性死区"></a>什么叫暂时性死区</h2><p>在作用域中（function）中用let&#x2F;const声明的变量会先被创建出来，但是又未进行词法绑定分析，是不能被访问的，访问就会抛出错误。<br>在这个流程创建到被访问之前的一段时间就被称为暂时性死区。</p><p>我的理解是 let&#x2F;const声明的变量 其实也进行了变量提升，只不过在访问前会抛出错误。</p><h2 id="手写一个好的深拷贝"><a href="#手写一个好的深拷贝" class="headerlink" title="手写一个好的深拷贝"></a>手写一个好的深拷贝</h2><ul><li>解决循环引用的问题</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>() <span class="hljs-comment">//为什么要用weakmap 不用map</span><br><span class="hljs-keyword">if</span>(map.<span class="hljs-title function_">get</span>(target))&#123;<br>  <span class="hljs-keyword">return</span> map.<span class="hljs-title function_">get</span>(target)<br>&#125;<br><span class="hljs-keyword">let</span> cloneObj = <span class="hljs-keyword">new</span> obj.<span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>)<br>map.<span class="hljs-title function_">set</span>(obj, cloneObj)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack-plugin &amp; webpack-loader</title>
    <link href="/2020/03/19/%E6%8F%90%E5%8D%87-webpack-plugin/"/>
    <url>/2020/03/19/%E6%8F%90%E5%8D%87-webpack-plugin/</url>
    
    <content type="html"><![CDATA[<p>写一个webpack的多语言插件</p><span id="more"></span><p>该插件是一个多语言插件，暂且叫它i18n，开源库的多语言文件一般是一个语言为一个文件，以element-ui库为例，类似这种</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//zh.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">el</span>: &#123;<br>    <span class="hljs-attr">colorpicker</span>: &#123;<br>      <span class="hljs-attr">confirm</span>: <span class="hljs-string">&#x27;确定&#x27;</span>,<br>      <span class="hljs-attr">clear</span>: <span class="hljs-string">&#x27;清空&#x27;</span>,<br>      <span class="hljs-attr">addX</span>: <span class="hljs-string">&#x27;添加 &#123;0&#125;&#x27;</span>,<br>    &#125;,<br>    <span class="hljs-attr">datepicker</span>: &#123;<br>      <span class="hljs-attr">now</span>: <span class="hljs-string">&#x27;此刻&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br><br><br><span class="hljs-comment">//common.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">common</span>: &#123;<br>    <span class="hljs-attr">confirm</span>: <span class="hljs-string">&#x27;OK&#x27;</span>,<br>    <span class="hljs-attr">clear</span>: <span class="hljs-string">&#x27;Clear&#x27;</span><br>    <span class="hljs-attr">now</span>: <span class="hljs-string">&#x27;Now&#x27;</span>,<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>每次新增一个词汇，都需要去每个文件里面一一添加，确实比较麻烦，我期望的是在一个文件里面能把所有的语言都一次添加完毕：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><br><span class="hljs-comment"># common.yml</span><br><br><span class="hljs-attr">confirm:</span><br>  <span class="hljs-attr">en:</span> <span class="hljs-string">OK</span><br>  <span class="hljs-attr">zh:</span> <span class="hljs-string">确定</span><br><br><span class="hljs-attr">clear:</span><br>  <span class="hljs-attr">en:</span> <span class="hljs-string">Clear</span><br>  <span class="hljs-attr">zh:</span> <span class="hljs-string">清空</span><br><br><span class="hljs-attr">addX:</span><br>  <span class="hljs-attr">en:</span> <span class="hljs-string">Add</span> <span class="hljs-string">$&#123;0&#125;</span><br>  <span class="hljs-attr">zh:</span> <span class="hljs-string">添加</span> <span class="hljs-string">$&#123;0&#125;</span><br><br></code></pre></td></tr></table></figure><p>其实文件类型无所谓，js也好，yml也好，只要能达到目的即可，个人喜欢yml，专门放内容的文件。</p><p>定义一个语言转换的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addGlobalFn</span>(<span class="hljs-params">target = <span class="hljs-variable language_">global</span> || <span class="hljs-variable language_">window</span></span>) &#123; <span class="hljs-comment">//nodejs也会用到，所以也加入了global</span><br><br>  target.<span class="hljs-property">getLang</span> = target.<span class="hljs-property">_L_</span> = <span class="hljs-function">(<span class="hljs-params">key, options</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// _L_(&#x27;insertX&#x27;,&#123;p:[&#x27;confirm&#x27;]&#125;) 添加 确定</span><br>    <span class="hljs-comment">//alias of params</span><br>    <span class="hljs-keyword">if</span> (!!options &amp;&amp; options.<span class="hljs-property">p</span>) &#123; options.<span class="hljs-property">params</span> = options.<span class="hljs-property">p</span> &#125;<br><br>    <span class="hljs-comment">//if optjions is string ,will covert to module</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> options == <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>      <span class="hljs-keyword">let</span> m = options;<br>      options = &#123; m &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//default options</span><br>    options = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">assign</span>(&#123;<br>      <span class="hljs-attr">m</span>: <span class="hljs-string">&#x27;common&#x27;</span>, <span class="hljs-comment">//m代表模块的意思，默认为common.yml文件</span><br>      <span class="hljs-attr">params</span>: []<br>    &#125;, options);<br><br>    <span class="hljs-keyword">let</span> text = <span class="hljs-title function_">find</span>(key, options.<span class="hljs-property">m</span>); <span class="hljs-comment">//从common模块下寻找insertX</span><br><br>    <span class="hljs-keyword">if</span> (!text &amp;&amp; (text !== <span class="hljs-string">&#x27;&#x27;</span>)) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`miss language dict key : <span class="hljs-subst">$&#123;key&#125;</span> at module <span class="hljs-subst">$&#123;options.m&#125;</span>`</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;dict missed&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//text变为&#x27;添加confirm&#x27;</span><br>    text = <span class="hljs-title function_">replaceVars</span>(text, options.<span class="hljs-property">params</span>)<br>    <span class="hljs-comment">//寻找confirm 然后将confirm替换</span><br>    options.<span class="hljs-property">params</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\\$\\&#123;<span class="hljs-subst">$&#123;index&#125;</span>&#125;`</span>, <span class="hljs-string">&#x27;ig&#x27;</span>)<br>      <span class="hljs-comment">// console.log(&#123; reg: text.match(reg) &#125;);</span><br>      <span class="hljs-keyword">if</span> (reg.<span class="hljs-title function_">test</span>(text)) &#123;<br><br>        <span class="hljs-keyword">let</span> reuseText = <span class="hljs-title function_">find</span>(item, <span class="hljs-string">&#x27;common&#x27;</span>);<br><br>        text = text.<span class="hljs-title function_">replace</span>(reg, reuseText);<br>      &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> text;<br>  &#125;<br><br><br>  <span class="hljs-comment">//替换变量 $&#123;0&#125;</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceVars</span>(<span class="hljs-params">text, params</span>) &#123;<br>    <span class="hljs-comment">//replace params to dict template</span><br>    params.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pText, index</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">`\\$\\&#123;<span class="hljs-subst">$&#123;index&#125;</span>\\&#125;`</span>, <span class="hljs-string">&#x27;ig&#x27;</span>);<br>      text = text.<span class="hljs-title function_">replace</span>(reg, pText);<br>    &#125;);<br><br>    <span class="hljs-keyword">return</span> text;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>替换方法写好了，接下来需要使用webpack插件编译yml文件并输出一个保存所有语言的js文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LangsPlugin</span> &#123;<br>  <span class="hljs-comment">// Define `apply` as its prototype method which is supplied with compiler as its argument</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">compiler</span>) &#123;<br>    <span class="hljs-comment">// Specify the event hook to attach to</span><br>    compiler.<span class="hljs-property">hooks</span>.<span class="hljs-property">afterPlugins</span>.<span class="hljs-title function_">tap</span>(<br>      <span class="hljs-string">&#x27;LangsPlugin&#x27;</span>,<br>      <span class="hljs-function">(<span class="hljs-params">context, entry</span>) =&gt;</span> &#123;<br><br>        <span class="hljs-comment">// Scan lang yaml file</span><br>        <span class="hljs-keyword">let</span> langFiles = fs.<span class="hljs-title function_">readdirSync</span>(<span class="hljs-title function_">resolve</span>(paths.<span class="hljs-property">langDir</span>));<br><br>        <span class="hljs-keyword">let</span> langObj = &#123;&#125;;<br>        <span class="hljs-keyword">let</span> keyByLang = &#123;&#125;;<br>        <span class="hljs-keyword">let</span> fileContent = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">&#x27;common.yml&#x27;</span>);<br>        <span class="hljs-keyword">let</span> fileLoaded = yaml.<span class="hljs-title function_">safeLoad</span>(fileContent);<span class="hljs-comment">//yaml: js-yml</span><br>        langObj.<span class="hljs-property">common</span> = fileLoaded;<br>        <span class="hljs-comment">// &#123;</span><br>        <span class="hljs-comment">//   common: &#123;</span><br>        <span class="hljs-comment">//     confirm: &#123; zh: &#x27;确定&#x27;, en: &#x27;OK&#x27; &#125;,</span><br>        <span class="hljs-comment">//     clear: &#123; zh: &#x27;清除&#x27;, en: &#x27;cancel&#x27; &#125;,</span><br>        <span class="hljs-comment">//     addX: &#123; zh: &#x27;添加$&#123;0&#125;&#x27;, en: &#x27;Add$&#123;0&#125;&#x27; &#125;,</span><br>        <span class="hljs-comment">//   &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>          <span class="hljs-comment">//修改数据结构，以语言类别为一级索引</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> fileLoaded) &#123;<br>          <span class="hljs-keyword">let</span> dictItem = fileLoaded[key];<br>          <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> lang <span class="hljs-keyword">in</span> dictItem) &#123;<br>            <span class="hljs-comment">//如果该语言没被创建，创建该语言</span><br>            <span class="hljs-keyword">if</span> (!keyByLang[lang]) &#123; keyByLang[lang] = &#123;&#125; &#125;;<br>            <span class="hljs-keyword">let</span> langItem = keyByLang[lang];<br><br>            <span class="hljs-comment">//创建模块</span><br>            <span class="hljs-keyword">if</span> (!langItem[filenameWithoutExt]) &#123; langItem[filenameWithoutExt] = &#123;&#125; &#125;<br>            langItem[filenameWithoutExt][key] = dictItem[lang];<br>          &#125;<br>        &#125;<br><br>        <span class="hljs-comment">//export files to output:</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> lang <span class="hljs-keyword">in</span> keyByLang) &#123;<br>          <span class="hljs-keyword">let</span> langItem = keyByLang[lang];<br>          <span class="hljs-keyword">let</span> code = <span class="hljs-string">&#x27;/*!!!! created by LangPlugin !!!!*/\n&#x27;</span>;<br>          <span class="hljs-comment">// code += `window.LANGUAGE.$&#123;lang&#125; = $&#123;util.inspect(langItem, &#123; depth: null &#125;)&#125;`;</span><br>          code += <span class="hljs-string">`window.LANGUAGE.<span class="hljs-subst">$&#123;lang&#125;</span> = <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(langItem)&#125;</span>`</span>;<br>          fs.<span class="hljs-title function_">outputFileSync</span>(<span class="hljs-title function_">resolve</span>(paths.<span class="hljs-property">langOutputDir</span>) + <span class="hljs-string">`/<span class="hljs-subst">$&#123;lang&#125;</span>.js`</span>, code);<br>        &#125;<br>        <span class="hljs-comment">//输出zh.js, en.js </span><br>        <span class="hljs-comment">// window.LANGUAGE.zh = &#123;</span><br>        <span class="hljs-comment">//   common: &#123;</span><br>        <span class="hljs-comment">//     confirm: &quot;确定&quot;,</span><br>        <span class="hljs-comment">//     cancel:&quot;取消&quot;</span><br>        <span class="hljs-comment">//   &#125;</span><br>        <span class="hljs-comment">// &#125;</span><br>      &#125;<br>    );<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>提升</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>css</title>
    <link href="/2020/01/06/%E5%9F%BA%E7%A1%80-css/"/>
    <url>/2020/01/06/%E5%9F%BA%E7%A1%80-css/</url>
    
    <content type="html"><![CDATA[<p>css相关</p><span id="more"></span><h2 id="使用text-align-last对齐两端文本"><a href="#使用text-align-last对齐两端文本" class="headerlink" title="使用text-align-last对齐两端文本"></a>使用text-align-last对齐两端文本</h2><h2 id="使用-not-去除无用属性"><a href="#使用-not-去除无用属性" class="headerlink" title="使用:not()去除无用属性"></a>使用:not()去除无用属性</h2><h2 id="使用attr-抓取data"><a href="#使用attr-抓取data" class="headerlink" title="使用attr()抓取data-*"></a>使用attr()抓取data-*</h2><p>在标签上自定义属性data-*，通过attr()获取其内容赋值到content上</p><p>参考 <a href="https://juejin.im/post/5d4d0ec651882549594e7293">https://juejin.im/post/5d4d0ec651882549594e7293</a></p><h2 id="关于网站换肤"><a href="#关于网站换肤" class="headerlink" title="关于网站换肤"></a>关于网站换肤</h2><p><a href="https://www.zhangxinxu.com/wordpress/2019/02/link-rel-alternate-website-skin/">https://www.zhangxinxu.com/wordpress/2019/02/link-rel-alternate-website-skin/</a></p><p>使用link rel&#x3D;alternate  语义化的东西， 实际是通过disabled控制link标签</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>react学习笔记</title>
    <link href="/2019/08/30/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-react/"/>
    <url>/2019/08/30/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-react/</url>
    
    <content type="html"><![CDATA[<p>react 相关</p><span id="more"></span><h2 id="isBatchingUpdate"><a href="#isBatchingUpdate" class="headerlink" title="isBatchingUpdate"></a>isBatchingUpdate</h2><p>在React的setState函数实现中，会根据一个变量 isBatchingUpdate 来判断是直接同步更新this.state还是放到队列中异步更新 。React使用了事务的机制，React的每个<strong>生命周期</strong>和<strong>合成事件</strong>都处在一个大的事务当中。在事务的前置钩子中调用batchedUpdates方法修改isBatchingUpdates变量为true，在后置钩子中将变量置为false。原生绑定事件和setTimeout异步的函数没有进入到React的事务当中，或者当他们执行时，刚刚的事务已近结束了，后置钩子触发了，所以此时的setState会直接进入非批量更新模式，表现在我们看来成为了同步SetState。</p><p>参考 <a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/18">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/18</a></p><h2 id="浏览器和Node-事件循环的区别"><a href="#浏览器和Node-事件循环的区别" class="headerlink" title="浏览器和Node 事件循环的区别"></a>浏览器和Node 事件循环的区别</h2><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/26</a></p><h2 id="React-Hook"><a href="#React-Hook" class="headerlink" title="React Hook"></a>React Hook</h2><p>参考 <a href="https://juejin.im/post/5d754dbde51d4561cd2466bf#heading-1">https://juejin.im/post/5d754dbde51d4561cd2466bf#heading-1</a></p><h3 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h3><p>相当于生命周期</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  message.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;componentDidMount&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    message.<span class="hljs-title function_">info</span>(<span class="hljs-string">&#x27;componentWillUnmout&#x27;</span>);<br>  &#125;;<br>&#125;, []);<br></code></pre></td></tr></table></figure><p>第二个参数为该副作用监听的状态数组，当对应状态发生变动时会执行副作用，<strong>如果第二个参数为空（不写），那么在每一个 State 变化时都会执行该副作用，如果是空数组，则相当于只触发一次</strong> </p><blockquote><p>在 useEffect 中，所有的变量的值都会保留在该副作用执行的时刻，类似于 for 循环中的 let 或者 闭包，所有的变量都维持在副作用执行时的状态，也有人称这个为 Capture Value。</p></blockquote><h3 id="useCallback"><a href="#useCallback" class="headerlink" title="useCallback"></a>useCallback</h3><p>对不同useEffect中存在的相同逻辑的封装，减少代码冗余，配合 useEffect 使用。</p><p>第一个参数为生成的回调方法，第二个参数为该方法关联的状态，任一状态发生变动都会重新生成新的回调。</p><h3 id="useRef"><a href="#useRef" class="headerlink" title="useRef"></a>useRef</h3><h3 id="useMemo-相当于vue的计算属性"><a href="#useMemo-相当于vue的计算属性" class="headerlink" title="useMemo  相当于vue的计算属性"></a>useMemo  相当于vue的计算属性</h3><p>第一个参数为一个 Getter 方法，返回值为要缓存的<strong>数据或组件</strong>，第二个参数为该返回值相关联的状态，当其中任何一个状态发生变化时就会重新调用 Getter 方法生成新的返回值。</p><h3 id="classnames库"><a href="#classnames库" class="headerlink" title="classnames库"></a>classnames库</h3>]]></content>
    
    
    <categories>
      
      <category>三方库使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http 与 缓存</title>
    <link href="/2019/06/29/%E5%9F%BA%E7%A1%80-http/"/>
    <url>/2019/06/29/%E5%9F%BA%E7%A1%80-http/</url>
    
    <content type="html"><![CDATA[<p>http缓存分为强缓存与协商缓存</p><span id="more"></span><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>不发送到服务器，直接从读取浏览器的本地缓存， 在Chrome中分为 Disk Cache (存放在硬盘中)和 Memory Cache (存放在内存中)，位置由浏览器控制<br>是否强缓存由 Expires、Cache-Control 和 Pragma 3 个 Header 属性共同来控制。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>Expires 的值是一个 HTTP 日期，在浏览器发起请求时，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。Expires 的优先级在三个 Header 属性中是最低的。</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>Cache-Control 是 HTTP&#x2F;1.1 中新增的属性，在请求头和响应头中都可以使用，常用的属性值如有：</p><p>max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效<br>no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜<br>no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源<br>private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应<br>public：响应可以被中间代理、CDN 等缓存<br>must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证</p><h3 id="Pragma"><a href="#Pragma" class="headerlink" title="Pragma"></a>Pragma</h3><p>只有一个属性值 no-cache，和Cache-Control一致，不使用强缓存，优先级最高</p><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>强缓存失效，或者设置请求头， 不走强缓存时，会走协商缓存</p><h3 id="响应头：ETag-请求头：-If-None-Match"><a href="#响应头：ETag-请求头：-If-None-Match" class="headerlink" title="响应头：ETag   请求头： If-None-Match"></a>响应头：ETag   请求头： If-None-Match</h3><p>一串hash码，服务端的文件变化时，hash码随之改变， 请求的etag、If-None-Match与当前文件的hash比较，如果相等，命中协商缓存</p><h3 id="响应头：-Last-Modified-请求头：-If-Modified-Since"><a href="#响应头：-Last-Modified-请求头：-If-Modified-Since" class="headerlink" title="响应头： Last-Modified  请求头： If-Modified-Since"></a>响应头： Last-Modified  请求头： If-Modified-Since</h3><p>表示文件的最后修改时间， 请一次请求服务端把资源的最后修改时间放到Last-Modified响应头中，第二次发起请求时，请求头会带上上一次响应头的Last-Modified时间，放入If-Modified-Since请求头，如果相等返回304，加载浏览器缓存。</p><p>ETag&#x2F;If-None-Match 的出现主要解决了 Last-Modified&#x2F;If-Modified-Since 所解决不了的问题：</p><p>如果文件的修改频率在秒级以下，Last-Modified&#x2F;If-Modified-Since 会错误地返回 304</p><p>如果文件被修改了，但是内容没有任何变化的时候，Last-Modified&#x2F;If-Modified-Since 会错误地返回 200， 期望的是304</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>notes</title>
    <link href="/2019/06/12/%E5%9F%BA%E7%A1%80-notes/"/>
    <url>/2019/06/12/%E5%9F%BA%E7%A1%80-notes/</url>
    
    <content type="html"><![CDATA[<p>学习笔记</p><span id="more"></span><h2 id="Object-freeze"><a href="#Object-freeze" class="headerlink" title="Object.freeze"></a>Object.freeze</h2><p>冻结对象，禁止修改对象 在vue处理大数据量时，取消数据劫持，提升性能非常有用</p><h2 id="class-继承封装组件"><a href="#class-继承封装组件" class="headerlink" title="class 继承封装组件"></a>class 继承封装组件</h2><h2 id="document-execCommand语法"><a href="#document-execCommand语法" class="headerlink" title="document.execCommand语法"></a>document.execCommand语法</h2><h2 id="class-单例模式"><a href="#class-单例模式" class="headerlink" title="class 单例模式"></a>class 单例模式</h2><h2 id="openseadragon大图展示库"><a href="#openseadragon大图展示库" class="headerlink" title="openseadragon大图展示库"></a>openseadragon大图展示库</h2><p><a href="http://openseadragon.github.io/examples/creating-zooming-images/">http://openseadragon.github.io/examples/creating-zooming-images/</a>   需要用到多层图片制作工具</p><h2 id="bind-this-每次都会返回一个新的函数"><a href="#bind-this-每次都会返回一个新的函数" class="headerlink" title="bind(this) 每次都会返回一个新的函数"></a>bind(this) 每次都会返回一个新的函数</h2><h2 id="robots-txt-保护内容不被搜索引擎抓取"><a href="#robots-txt-保护内容不被搜索引擎抓取" class="headerlink" title="robots.txt 保护内容不被搜索引擎抓取"></a>robots.txt 保护内容不被搜索引擎抓取</h2><h2 id="webapack插件编写"><a href="#webapack插件编写" class="headerlink" title="webapack插件编写"></a>webapack插件编写</h2><h2 id="gulp与webpack混合构建"><a href="#gulp与webpack混合构建" class="headerlink" title="gulp与webpack混合构建"></a>gulp与webpack混合构建</h2><h2 id="js实现队列与栈"><a href="#js实现队列与栈" class="headerlink" title="js实现队列与栈"></a>js实现队列与栈</h2><h2 id="word-break、word-wrap、white-space"><a href="#word-break、word-wrap、white-space" class="headerlink" title="word-break、word-wrap、white-space"></a>word-break、word-wrap、white-space</h2><ul><li>white-space，控制空白字符的显示，同时还能控制是否自动换行。它有五个值：normal | nowrap | pre | pre-wrap | pre-line</li><li>word-break，控制单词如何被拆分换行。它有三个值：normal | break-all | keep-all</li><li>word-wrap（overflow-wrap）控制长度超过一行的单词是否被拆分换行，是word-break的补充，它有两个值：normal | break-word</li></ul><h2 id="filter-Boolean-过滤数组中undefined-null-false的项"><a href="#filter-Boolean-过滤数组中undefined-null-false的项" class="headerlink" title="[].filter(Boolean) 过滤数组中undefined null false的项"></a>[].filter(Boolean) 过滤数组中undefined null false的项</h2><h2 id="宏任务与微任务"><a href="#宏任务与微任务" class="headerlink" title="宏任务与微任务"></a>宏任务与微任务</h2><p>任务队列分宏任务与微任务，在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microtasks 队列清空<br>运行完宏任务，则开始运行微任务</p><h2 id="new运算符"><a href="#new运算符" class="headerlink" title="new运算符"></a>new运算符</h2><ol><li>创建一个空的简单JavaScript对象（即{}）；</li><li>链接该对象（即设置该对象的构造函数）到另一个对象 ；</li><li>将步骤1新创建的对象作为this的上下文 ；</li><li>如果该函数没有返回对象，则返回this。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">_new</span>(<span class="hljs-params">fn, ...arg</span>) &#123;<br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>    <span class="hljs-keyword">const</span> ret = fn.<span class="hljs-title function_">apply</span>(obj, arg);<br>    <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span> ? ret : obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="标签页间的通信，-通过window-open第二个参数"><a href="#标签页间的通信，-通过window-open第二个参数" class="headerlink" title="标签页间的通信， 通过window.open第二个参数"></a>标签页间的通信， 通过window.open第二个参数</h2><h2 id="package-json-workspaces、bin-等作用"><a href="#package-json-workspaces、bin-等作用" class="headerlink" title="package.json  workspaces、bin 等作用"></a>package.json  workspaces、bin 等作用</h2><h2 id="arguments、callee、caller"><a href="#arguments、callee、caller" class="headerlink" title="arguments、callee、caller"></a>arguments、callee、caller</h2><p>callee是arguments对象的一个成员，它的值为“正被执行的Function对象”。</p><p>caller是函数对象的一个静态属性，该属性保存着调用当前函数的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//child是parent内的函数，并在parent内执行child</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">child</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-comment">//这里child的父函数就是parent</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>( child.<span class="hljs-property">caller</span> ); <span class="hljs-comment">//相当于console.log(parent)</span><br>    &#125;<br>    <span class="hljs-title function_">child</span>();<br>&#125;<br><span class="hljs-comment">//parent1没有被别人调用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parent1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//这里parent1没有父函数</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(parent1.<span class="hljs-property">caller</span>); <span class="hljs-comment">//null</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="setInterval-与setTimeout-计时区别-建议用setTimeout"><a href="#setInterval-与setTimeout-计时区别-建议用setTimeout" class="headerlink" title="setInterval 与setTimeout 计时区别  建议用setTimeout"></a>setInterval 与setTimeout 计时区别  建议用setTimeout</h2><p><strong>尽量不用setInterval()</strong></p><ol><li>setInterval()无视代码错误</li><li>setInterval无视网络延迟，如果ajax请求有一定延迟，setInterval还是会不断的发起请求，导致网络队列塞满ajax请求</li><li>setInterval不保证执行</li></ol><h2 id="长列表（虚拟列表）"><a href="#长列表（虚拟列表）" class="headerlink" title="长列表（虚拟列表）"></a>长列表（虚拟列表）</h2><h2 id="git-remote-设置用户名密码"><a href="#git-remote-设置用户名密码" class="headerlink" title="git remote 设置用户名密码"></a>git remote 设置用户名密码</h2><p>http:&#x2F;&#x2F;[用户名]:[密码]@[git地址]</p><h2 id="requestAnimationFrame好处及作用"><a href="#requestAnimationFrame好处及作用" class="headerlink" title="requestAnimationFrame好处及作用"></a>requestAnimationFrame好处及作用</h2><h2 id="will-change提升元素为合成层，脱离重绘重排"><a href="#will-change提升元素为合成层，脱离重绘重排" class="headerlink" title="will-change提升元素为合成层，脱离重绘重排"></a>will-change提升元素为合成层，脱离重绘重排</h2>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>提升开发效率</title>
    <link href="/2019/06/04/%E5%B7%A5%E5%85%B7-utils/"/>
    <url>/2019/06/04/%E5%B7%A5%E5%85%B7-utils/</url>
    
    <content type="html"><![CDATA[<p>工具</p><span id="more"></span><h2 id="eslint配合vscode自动纠错"><a href="#eslint配合vscode自动纠错" class="headerlink" title="eslint配合vscode自动纠错"></a>eslint配合vscode自动纠错</h2><p>首先需要vscode添加eslint插件；<br>然后项目添加.eslintrc.js文件，根据extends字段中的规则下载相应的npm纠错检测包，例如使用standard风格。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//.eslintrc.js</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&quot;standard&quot;</span> <span class="hljs-comment">//采用的流行风格</span><br>  ],<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&quot;no-new&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;eqeqeq&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-unreachable&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-useless-escape&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-mixed-operators&quot;</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">globals</span>: &#123;<br>    <span class="hljs-string">&quot;$&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>当采用这规则时，vscode会自动提示加载不到eslint-config-standard包，所以需要我们自己去下载<br>下面是需要下载的npm包</p><ul><li>eslint</li><li>eslint-config-standard</li><li>eslint-plugin-standard</li><li>eslint-plugin-import</li><li>eslint-plugin-node</li><li>eslint-plugin-promise</li></ul><p>当前只是针对js文件的js代码进行纠错，其实还有vue文件，ts文件，html都可以纠错，只需下载相应npm包即可</p><p>如果需要对html文件中的js代码纠错,那么需要在plugins字段中添加html，同时下载eslint-plugin-html。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&quot;standard&quot;</span>,<br>  ],<br>  <span class="hljs-attr">plugins</span>:[<br>    <span class="hljs-string">&#x27;html&#x27;</span><br>  ],<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&quot;no-new&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;eqeqeq&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-unreachable&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-useless-escape&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-mixed-operators&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;no-tabs&quot;</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">globals</span>: &#123;<br>    <span class="hljs-string">&quot;$&quot;</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加vscode配置： 文件 -&gt; 首选项 -&gt; 设置 -&gt; setting.json</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&quot;eslint.validate&quot;</span>: [<br>  &#123; <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;html&quot;</span>, <span class="hljs-string">&quot;autoFix&quot;</span>: <span class="hljs-literal">true</span> &#125;,<br>],<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>webpack核心原理</title>
    <link href="/2019/05/18/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-webpack/"/>
    <url>/2019/05/18/%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6-webpack/</url>
    
    <content type="html"><![CDATA[<p>简单写写webopack是怎么打包并解析依赖的</p><span id="more"></span><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li>读取入口文件内容</li><li>使用@babel&#x2F;parser将代码转化成AST语法树</li><li>使用 @babel&#x2F;traverse 层层收集 import 依赖</li></ol><h3 id="需要编译的代码例子"><a href="#需要编译的代码例子" class="headerlink" title="需要编译的代码例子"></a>需要编译的代码例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//main.js</span><br><br><span class="hljs-keyword">import</span> add <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./add.js&quot;</span><br><span class="hljs-keyword">import</span> &#123;minus&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./minus.js&quot;</span>;<br><br><span class="hljs-keyword">const</span> sum = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> division = <span class="hljs-title function_">minus</span>(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(division);<br><br><span class="hljs-comment">//add.js</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (a,b)=&gt;&#123;<br>  <span class="hljs-keyword">return</span> a+b;<br>&#125;<br><br><span class="hljs-comment">//minus</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title function_">minus</span> = (<span class="hljs-params">a,b</span>)=&gt;&#123;<br>    <span class="hljs-keyword">return</span> a-b<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getModuleInfo</span>(<span class="hljs-params">file</span>)=&gt;&#123; <span class="hljs-comment">//根据路径获取文件内容</span><br>  <span class="hljs-keyword">const</span> body = fs.<span class="hljs-title function_">readFileSync</span>(file,<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br>  <span class="hljs-keyword">const</span> ast = parser.<span class="hljs-title function_">parse</span>(body,&#123;<br>    <span class="hljs-attr">sourceType</span>:<span class="hljs-string">&#x27;module&#x27;</span> <span class="hljs-comment">//表示解析的是ES模块</span><br>  &#125;);<br>  <span class="hljs-keyword">const</span> deps = &#123;&#125;<br>  <span class="hljs-title function_">traverse</span>(ast,&#123;<br>    <span class="hljs-title class_">ImportDeclaration</span>(&#123;node&#125;)&#123;<br>      <span class="hljs-keyword">const</span> dirname = path.<span class="hljs-title function_">dirname</span>(file)<br>      <span class="hljs-keyword">const</span> abspath = <span class="hljs-string">&quot;./&quot;</span> + path.<span class="hljs-title function_">join</span>(dirname,node.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>)<br>      deps[node.<span class="hljs-property">source</span>.<span class="hljs-property">value</span>] = abspath <span class="hljs-comment">//获取到依赖的绝对路径</span><br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> &#123;code&#125; = babel.<span class="hljs-title function_">transformFromAst</span>(ast,<span class="hljs-literal">null</span>,&#123;<br>    <span class="hljs-attr">presets</span>:[<span class="hljs-string">&quot;@babel/preset-env&quot;</span>] <span class="hljs-comment">//作用是将AST代码转化成 第三个参数里配置的模块类型 比如@babel/preset-env的规范会将const转化成var</span><br>  &#125;)<br><br>  <span class="hljs-keyword">const</span> moduleInfo = &#123;<br>    file, <span class="hljs-comment">//文件路径</span><br>    deps, <span class="hljs-comment">//依赖</span><br>    code  <span class="hljs-comment">//转化为es5的代码</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> moduleInfo<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在需要获取每个模块依赖的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">parseModules</span> = (<span class="hljs-params">file</span>) =&gt;&#123;<br>  <span class="hljs-keyword">const</span> entry =  <span class="hljs-title function_">getModuleInfo</span>(file)<br>  <span class="hljs-keyword">const</span> temp = [entry]<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; temp.<span class="hljs-property">length</span>;i++)&#123;<br>    <span class="hljs-keyword">const</span> deps = temp[i].<span class="hljs-property">deps</span><br>    <span class="hljs-keyword">if</span> (deps)&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> deps)&#123;<br>        <span class="hljs-keyword">if</span> (deps.<span class="hljs-title function_">hasOwnProperty</span>(key))&#123;<br>          temp.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">getModuleInfo</span>(deps[key])) <span class="hljs-comment">//又对tmp push了</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>调用 上面方法 parseModules(“.&#x2F;main.js”)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// index.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span><br><span class="hljs-keyword">var</span> _add = <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./add.js&quot;</span>));<br><span class="hljs-keyword">var</span> _minus = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./minus.js&quot;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) &#123; <span class="hljs-keyword">return</span> obj &amp;&amp; obj.<span class="hljs-property">__esModule</span> ? obj : &#123; <span class="hljs-string">&quot;default&quot;</span>: obj &#125;; &#125;<br><span class="hljs-keyword">var</span> sum = (<span class="hljs-number">0</span>, _add[<span class="hljs-string">&quot;default&quot;</span>])(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">var</span> division = (<span class="hljs-number">0</span>, _minus.<span class="hljs-property">minus</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(division);<br><br><span class="hljs-comment">//add.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>&#125;);<br><span class="hljs-built_in">exports</span>[<span class="hljs-string">&quot;default&quot;</span>] = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> _default = <span class="hljs-keyword">function</span> <span class="hljs-title function_">_default</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;<br><span class="hljs-built_in">exports</span>[<span class="hljs-string">&quot;default&quot;</span>] = _default;<br><br></code></pre></td></tr></table></figure><p>现在的问题是浏览器不识别require、exports，需要自定义这2个函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">bundle</span> = (<span class="hljs-params">file</span>) =&gt;&#123;<br>  <span class="hljs-keyword">const</span> depsGraph = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-title function_">parseModules</span>(file)) <span class="hljs-comment">//自定义一个require</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">`(function (graph) &#123;</span><br><span class="hljs-string">    function require(file) &#123; </span><br><span class="hljs-string">      function absRequire(relPath) &#123;</span><br><span class="hljs-string">        return require(graph[file].deps[relPath])</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">      (function (require,code) &#123;</span><br><span class="hljs-string">        eval(code)</span><br><span class="hljs-string">      &#125;)(absRequire,graph[file].code)</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    require(file)</span><br><span class="hljs-string">  &#125;)(depsGraph)`</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>执行顺序：</p><p>执行 require(‘.&#x2F;main.js’) 函数，相当于执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>,code</span>) &#123;<br>    <span class="hljs-built_in">eval</span>(code)<br>&#125;)(absRequire,graph[file].<span class="hljs-property">code</span>)<br></code></pre></td></tr></table></figure><p>执行了code代码， code代码是这样的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//main.js</span><br><span class="hljs-keyword">var</span> _add = <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./add.js&quot;</span>));<br><span class="hljs-keyword">var</span> _minus = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./minus.js&quot;</span>);<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-params">obj</span>) &#123; <span class="hljs-keyword">return</span> obj &amp;&amp; obj.<span class="hljs-property">__esModule</span> ? obj : &#123; <span class="hljs-string">&quot;default&quot;</span>: obj &#125;; &#125;<br><span class="hljs-keyword">var</span> sum = (<span class="hljs-number">0</span>, _add[<span class="hljs-string">&quot;default&quot;</span>])(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">var</span> division = (<span class="hljs-number">0</span>, _minus.<span class="hljs-property">minus</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(division);<br></code></pre></td></tr></table></figure><p>先不管_interopRequireDefault函数， 先看参数，参数是require 相当于执行了require，这个require其实是 absRequire</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">absRequire</span>(<span class="hljs-params">relPath</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(graph[file].<span class="hljs-property">deps</span>[relPath])<br>&#125;<br></code></pre></td></tr></table></figure><p>absRequire又执行了require，实际就是外层定义的require，现在的require参数是个绝对路径</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">require</span>(<span class="hljs-params">file</span>) &#123; <span class="hljs-comment">//执行了这个require</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">absRequire</span>(<span class="hljs-params">relPath</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(graph[file].<span class="hljs-property">deps</span>[relPath])<br>  &#125;<br>  (<span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>,code</span>) &#123;<br>    <span class="hljs-built_in">eval</span>(code)<br>  &#125;)(absRequire,graph[file].<span class="hljs-property">code</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行 require(&#x2F;src&#x2F;add.js)参数是绝对路径， 然后执行eval相当于执行add.js代码。利用了递归</p><p>在看下add.js代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//add.js</span><br><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(<span class="hljs-built_in">exports</span>, <span class="hljs-string">&quot;__esModule&quot;</span>, &#123;  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>&#125;);<br><span class="hljs-built_in">exports</span>[<span class="hljs-string">&quot;default&quot;</span>] = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> _default = <span class="hljs-keyword">function</span> <span class="hljs-title function_">_default</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;;<br><span class="hljs-built_in">exports</span>[<span class="hljs-string">&quot;default&quot;</span>] = _default;<br><br><span class="hljs-comment">//相当于</span><br><span class="hljs-built_in">exports</span> = &#123;<br>  __esModule：&#123;  <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span>&#125;，<br>  <span class="hljs-keyword">default</span>：<span class="hljs-keyword">function</span> <span class="hljs-title function_">_default</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">exports</span> <span class="hljs-comment">//return出去</span><br><br><span class="hljs-comment">//回到_interopRequireDefault</span><br><span class="hljs-keyword">var</span> _add = <span class="hljs-title function_">_interopRequireDefault</span>(<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;./add.js&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>_interopRequireDefault需要做的就是取出default属性</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现require用的是闭包加递归来处理路径的问题 export自定义即可</p>]]></content>
    
    
    <categories>
      
      <category>原理探究</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gc</title>
    <link href="/2019/05/12/%E5%9F%BA%E7%A1%80-gc/"/>
    <url>/2019/05/12/%E5%9F%BA%E7%A1%80-gc/</url>
    
    <content type="html"><![CDATA[<p>js 垃圾回收机制</p><span id="more"></span><h2 id="gc做了什么"><a href="#gc做了什么" class="headerlink" title="gc做了什么"></a>gc做了什么</h2><ul><li>找到内存空间的垃圾</li><li>回收垃圾，能再次利用这部分空间</li></ul><h2 id="gc算法"><a href="#gc算法" class="headerlink" title="gc算法"></a>gc算法</h2><p><strong>引用计数法</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>(); <span class="hljs-comment">// 此时&#x27;这个对象&#x27;的引用计数为1（a在引用）</span><br><span class="hljs-keyword">var</span> b = a; <span class="hljs-comment">// ‘这个对象’的引用计数是2（a,b）</span><br>a = <span class="hljs-literal">null</span>; <span class="hljs-comment">// reference_count = 1</span><br>b = <span class="hljs-literal">null</span>; <span class="hljs-comment">// reference_count = 0 </span><br><span class="hljs-comment">// 下一步 GC来回收‘这个对象’了</span><br><br></code></pre></td></tr></table></figure><p>优点： </p><ol><li>当引用数为0时，可即刻回收垃圾，对象马上会把自己作为空闲空间连到空闲链表上，也就是说。在变成垃圾的时候就立刻被回收</li><li>因为是即时回收,那么‘程序’不会暂停去单独使用很长一段时间的GC，那么最大暂停时间很短</li><li>不用去遍历堆里面的所有活动对象和非活动对象</li></ol><p>缺点：</p><ol><li>计数器需要占很大的位置，因为不能预估被引用的上限，打个比方，可能出现32位即2的32次方个对象同时引用一个对象，那么计数器就需要32位。</li><li>最大的劣势是无法解决循环引用无法回收的问题 这就是前文中IE9之前出现的问题</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">var</span> o = &#123;&#125;;<br>  <span class="hljs-keyword">var</span> o2 = &#123;&#125;;<br>  o.<span class="hljs-property">a</span> = o2; <span class="hljs-comment">// o 引用 o2,o2的引用次数是1</span><br>  o2.<span class="hljs-property">a</span> = o; <span class="hljs-comment">// o2 引用 o,o的引用此时是1</span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;azerty&quot;</span>;<br>&#125;<br><span class="hljs-title function_">f</span>();<br></code></pre></td></tr></table></figure><blockquote><p>引用计数法已经被标记-清除算法替代，在V8引擎里面，使用最多的就是 标记-清除算法</p></blockquote><p><strong>标记-清除法</strong></p><p>分两个阶段：</p><p>标记阶段： 把活动对象都标记上<br>清除阶段： 把没有标记（非活动对象）的销毁</p><p>GC从全局作用域开始沿作用域逐层遍历（深度遍历），能从根部到达的对象，说明该对象是被引用的，则打上标记。无法由根部触及到的对象被标记为不再使用，稍后回收<br>这种方法可以解决循环引用的问题，因为从全局作用域开始遍历时，遍历不到这2个对象</p><p>标记完成后进入清除阶段，这次是遍历堆，清除没有标记的对象</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue + Typesctipt 开发实践</title>
    <link href="/2019/05/07/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-vue-ts2/"/>
    <url>/2019/05/07/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-vue-ts2/</url>
    
    <content type="html"><![CDATA[<p>vue结合typescript在实际开发中遇到的问题</p><span id="more"></span><h2 id="refs类型声明（vue组件及dom节点）"><a href="#refs类型声明（vue组件及dom节点）" class="headerlink" title="$refs类型声明（vue组件及dom节点）"></a>$refs类型声明（vue组件及dom节点）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;app&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav-bar</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;navBar&quot;</span> /&gt;</span> <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">Vue</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">NavBar</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./NavBar.vue&#x27;</span>;</span><br><span class="language-javascript">  @<span class="hljs-title class_">Component</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">DetailPopup</span>,</span><br><span class="language-javascript">      <span class="hljs-title class_">NavBar</span>,</span><br><span class="language-javascript">      <span class="hljs-title class_">DownloadPopup</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vue</span> &#123;</span><br><span class="language-javascript">    public $refs!: &#123; <span class="hljs-comment">// strictPropertyInitialization 需要对所有的实际属性赋值 所以需要加感叹号</span></span><br><span class="language-javascript">      <span class="hljs-attr">app</span>: <span class="hljs-title class_">HTMLDivElement</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">navBar</span>: <span class="hljs-title class_">NavBar</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用到ref时，需要有相应的类型声明</p><h2 id="挂载到Vue原型下的方法声明"><a href="#挂载到Vue原型下的方法声明" class="headerlink" title="挂载到Vue原型下的方法声明"></a>挂载到Vue原型下的方法声明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//main.js</span><br><br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">$setTitle</span> = <span class="hljs-function">(<span class="hljs-params">title: string</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">title</span> = title + <span class="hljs-string">&#x27;_全历史&#x27;</span>;<br>&#125;;<br><span class="hljs-title class_">Vue</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">wakeupApp</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">from</span>: string = <span class="hljs-string">&#x27;m_site&#x27;</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> t = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>  <span class="hljs-keyword">const</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/https?:/gi</span>, <span class="hljs-string">&#x27;__ALLHISTORY_APP_HOST__&#x27;</span>);<br>  <span class="hljs-keyword">const</span> timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> c = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>    <span class="hljs-keyword">if</span> (c - t &gt; <span class="hljs-number">1200</span>) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> downloadUrl = <span class="hljs-string">&#x27;__ALLHISTORY_DOMAIN_HOSTNAME__/staticPage/download&#x27;</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>) &#123;<br>      downloadUrl += <span class="hljs-string">`/<span class="hljs-subst">$&#123;<span class="hljs-keyword">from</span>&#125;</span>`</span>;<br>    &#125;<br>    downloadUrl += <span class="hljs-string">`?rt=<span class="hljs-subst">$&#123;<span class="hljs-built_in">encodeURIComponent</span>(url)&#125;</span>`</span>;<br>    <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = downloadUrl;<br>  &#125;, <span class="hljs-number">1000</span>);<br>  <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = url;<br>&#125;;<br><br><span class="hljs-comment">//vue.d.ts</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br>declare <span class="hljs-variable language_">module</span> <span class="hljs-string">&#x27;vue/types/vue&#x27;</span> &#123;<br>  interface <span class="hljs-title class_">Vue</span> &#123;<br>    $setTitle(<span class="hljs-attr">title</span>:string):<span class="hljs-keyword">void</span>,<br>    <span class="hljs-attr">wakeupApp</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-keyword">from</span>?: string</span>) =&gt;</span> <span class="hljs-keyword">void</span><br>    <span class="hljs-comment">// $message:</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>事实上 <strong>declare module ‘vue&#x2F;types&#x2F;vue’</strong> 意为在 node_module&#x2F;vue&#x2F;types&#x2F;vue.d.ts 追加声明接口类型</p><h2 id="全局global声明"><a href="#全局global声明" class="headerlink" title="全局global声明"></a>全局global声明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">WeChart</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../utils/wechart&#x27;</span>;<br>declare <span class="hljs-variable language_">global</span> &#123;<br>  interface <span class="hljs-title class_">Window</span> &#123;<br>    <span class="hljs-attr">wechart</span>: <span class="hljs-title class_">WeChart</span>,<br>  &#125;<br>&#125;  <br></code></pre></td></tr></table></figure><p>有时我们会遇到挂载到window下的自定义方法，这时需要在global下的window中进行类型声明</p><h2 id="类型断言-as"><a href="#类型断言-as" class="headerlink" title="类型断言 as"></a>类型断言 as</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>public <span class="hljs-title function_">close</span>(<span class="hljs-params">e: Event</span>) &#123; <span class="hljs-comment">//e.target类型为EventTarget 但是该对象下没有classList属性</span><br>  <span class="hljs-keyword">const</span> target = e.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Element</span>; <span class="hljs-comment">//当我们只需要知道点击对象的classList时，可以断言为Element类型。因为只有Element类型下有classList属性</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">classList</span>.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;popup-mask&#x27;</span>)) &#123; <br>    e.<span class="hljs-title function_">stopPropagation</span>();<br>    <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;close-pop&#x27;</span>);<br>  &#125;<br>&#125;<br><br>public <span class="hljs-title function_">onLinkClick</span>(<span class="hljs-params">id: number, e: Event</span>) &#123;<br>  <span class="hljs-keyword">const</span> target = e.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">Node</span>;<br>  <span class="hljs-keyword">if</span> (target &amp;&amp; target.<span class="hljs-property">nodeName</span> === <span class="hljs-string">&#x27;A&#x27;</span>) &#123; <span class="hljs-comment">//用到了nodeName属性，证明点击的对象是在节点类型的基础上操作</span><br>    <span class="hljs-keyword">return</span> ;<br>  &#125;<br>  <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;on-link-click&#x27;</span>, id);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">Dom</span> = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#aricleDetail&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLDivElement</span>;<br><span class="hljs-title class_">Dom</span>.<span class="hljs-property">style</span>.<span class="hljs-property">color</span> = <span class="hljs-string">&#x27;red&#x27;</span>;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>三方库使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue + Typesctipt 开发准备</title>
    <link href="/2019/04/19/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-vue-ts/"/>
    <url>/2019/04/19/%E4%B8%89%E6%96%B9%E5%BA%93%E4%BD%BF%E7%94%A8-vue-ts/</url>
    
    <content type="html"><![CDATA[<p>利用vue-cli3.0对typescript的支持，直接开始搭建环境。</p><span id="more"></span><h2 id="vue-cli3-0配置选择"><a href="#vue-cli3-0配置选择" class="headerlink" title="vue-cli3.0配置选择"></a>vue-cli3.0配置选择</h2><p><img src="/images/vue-typescript/cli-config.png" alt="cli-config"></p><blockquote><p>这里需要注意的是:为了提升编码效率，配合vscode的自动纠错功能必须选择tslint以对ts文件进行自动纠错</p></blockquote><h2 id="vscode插件安装"><a href="#vscode插件安装" class="headerlink" title="vscode插件安装"></a>vscode插件安装</h2><p><img src="/images/vue-typescript/vscode-extensions.png" alt="cli-config"></p><blockquote><p>TSLint插件是对ts文件进行自动纠错，TSLint Vue 是对vue文件中的ts语法进行自动纠错，这2个插件实际上是依赖于Vetur插件</p></blockquote><p>安装完插件后在setting.json中配置以启用tslint插件</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;tslint.autoFixOnSave&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br></code></pre></td></tr></table></figure><h2 id="vue支持TS的官方组件"><a href="#vue支持TS的官方组件" class="headerlink" title="vue支持TS的官方组件"></a>vue支持TS的官方组件</h2><ul><li><p><a href="https://github.com/vuejs/vue-class-component">vue-class-component</a> : Vue对TS的支持组件，使用 TypeScript&#x2F;装饰器 </p></li><li><p><a href="https://github.com/kaorun343/vue-property-decorator">vue-property-decorator</a> : 在 vue-class-component 上增强更多的结合 Vue 特性的装饰器</p></li><li><p><a href="https://github.com/ktsn/vuex-class/">vuex-class</a> : vuex的支持组件</p></li></ul><p>由于vue-property-decorator是在vue-class-component进行的扩展，所以只需要引入vue-property-decorator和vuex-class</p><h2 id="vue-property-decorator"><a href="#vue-property-decorator" class="headerlink" title="vue-property-decorator"></a>vue-property-decorator</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;home&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Vue logo&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;../assets/logo.png&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">HelloWorld</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;Welcome to Your Vue.js + TypeScript App&quot;</span>/&gt;</span></span><br><span class="language-xml">    &#123;&#123;computedMsg&#125;&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">Vue</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-property-decorator&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/HelloWorld.vue&#x27;</span>; <span class="hljs-comment">// @ is an alias to /src</span></span></span><br><span class="language-javascript"><span class="language-xml">  @<span class="hljs-title class_">Component</span>  </span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vue</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 初始化数据</span></span></span><br><span class="language-javascript"><span class="language-xml">    public msg = <span class="hljs-string">&#x27;123&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 声明周期钩子函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    public <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">greet</span>();</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 计算属性</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">get</span> <span class="hljs-title function_">computedMsg</span>() &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;computed &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">set</span> <span class="hljs-title function_">computedMsg</span>(<span class="hljs-params">val</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span> = val;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-comment">// 方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    public <span class="hljs-title function_">greet</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;greeting: &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">msg</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>上面的代码同下面的代码</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">export default &#123;<br>  <span class="hljs-keyword">data</span> () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      msg: <span class="hljs-string">&#x27;123&#x27;</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 声明周期钩子</span><br>  mounted () &#123;<br>    <span class="hljs-keyword">this</span>.greet()<br>  &#125;<br><br>  <span class="hljs-comment">// 计算属性</span><br>  computed: &#123;<br>    computedMsg: &#123;<br>      <span class="hljs-comment">// getter</span><br>      <span class="hljs-keyword">get</span>: function () &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;computed &#x27;</span> + <span class="hljs-keyword">this</span>.msg;<br>      &#125;,<br>      <span class="hljs-comment">// setter</span><br>      <span class="hljs-keyword">set</span>: function (<span class="hljs-keyword">val</span>) &#123;<br>        <span class="hljs-keyword">this</span>.msg = <span class="hljs-keyword">val</span>;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 方法</span><br>  methods: &#123;<br>    greet () &#123;<br>      alert(<span class="hljs-string">&#x27;greeting: &#x27;</span> + <span class="hljs-keyword">this</span>.msg)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="添加router生命周期钩子函数"><a href="#添加router生命周期钩子函数" class="headerlink" title="添加router生命周期钩子函数"></a>添加router生命周期钩子函数</h3><p>在用到vue插件，比如vue-router的生命周期钩子函数的时候，我们需要用Component.registerHooks注册后才会生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">Vue</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-property-decorator&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Route</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-title class_">Component</span>.<span class="hljs-title function_">registerHooks</span>([<br>  <span class="hljs-string">&#x27;beforeRouteEnter&#x27;</span>,<br>  <span class="hljs-string">&#x27;beforeRouteLeave&#x27;</span>,<br>  <span class="hljs-string">&#x27;beforeRouteUpdate&#x27;</span>, <span class="hljs-comment">// for vue-router 2.2+</span><br>]);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vue</span> &#123;<br>  public <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to: Route, <span class="hljs-keyword">from</span>: Route, next: () =&gt; <span class="hljs-keyword">void</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeRouteEnter&#x27;</span>);<br>    <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// needs to be called to confirm the navigation</span><br>  &#125;<br><br>  public <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to: Route, <span class="hljs-keyword">from</span>: Route, next: () =&gt; <span class="hljs-keyword">void</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeRouteLeave&#x27;</span>);<br>    <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// needs to be called to confirm the navigation</span><br>  &#125;<br><br>  public <span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to: Route, <span class="hljs-keyword">from</span>: Route, next: () =&gt; <span class="hljs-keyword">void</span></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeRouteLeave&#x27;</span>);<br>    <span class="hljs-title function_">next</span>(); <span class="hljs-comment">// needs to be called to confirm the navigation</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这里需要注意的是@Component需要加在每个vue文件上，否则引用此组件时会报错。</strong></p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>@Emit</li><li>@Inject</li><li>@Model</li><li>@Prop</li><li>@Provide</li><li>@Watch</li><li>@Component</li></ul><p>列举常用的@Prop @Watch @Component @Emit</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br>&lt;script lang=<span class="hljs-string">&quot;ts&quot;</span>&gt;<br><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">Vue</span>, <span class="hljs-title class_">Component</span>, <span class="hljs-title class_">Prop</span>, <span class="hljs-title class_">Emit</span>, <span class="hljs-title class_">Watch</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-property-decorator&#x27;</span>;<br>@<span class="hljs-title class_">Component</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vue</span> &#123;<br>  public count = <span class="hljs-number">0</span>;<br>  @<span class="hljs-title class_">Prop</span>() public readonly propA!: number; <span class="hljs-comment">//变量后加！的原因是TS在声明变量时必须赋初始值，如</span><br>                                          <span class="hljs-comment">//果不赋值则需要加！，否则将会报错</span><br>  @<span class="hljs-title class_">Prop</span>(&#123; <span class="hljs-attr">default</span>: <span class="hljs-string">&#x27;默认值&#x27;</span> &#125;) public readonly propB!: string;<br>  @<span class="hljs-title class_">Prop</span>() public readonly propC!: string | boolean;<br>  <span class="hljs-comment">// props: &#123;</span><br>  <span class="hljs-comment">//   propA: &#123;</span><br>  <span class="hljs-comment">//     type: Number</span><br>  <span class="hljs-comment">//   &#125;,</span><br>  <span class="hljs-comment">//   propB: &#123;</span><br>  <span class="hljs-comment">//     default: &#x27;default value&#x27;</span><br>  <span class="hljs-comment">//   &#125;,</span><br>  <span class="hljs-comment">//   propC: &#123;</span><br>  <span class="hljs-comment">//     type: [String, Boolean]</span><br>  <span class="hljs-comment">//   &#125;,</span><br>  <span class="hljs-comment">// &#125;</span><br>  @<span class="hljs-title class_">Watch</span>(<span class="hljs-string">&#x27;count&#x27;</span>)<br>  public <span class="hljs-title function_">onChildChanged</span>(<span class="hljs-params">val: string, oldVal: string</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span>);<br>   &#125;<br><br>  @<span class="hljs-title class_">Watch</span>(<span class="hljs-string">&#x27;person&#x27;</span>, &#123; <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span> &#125;)<br>  public <span class="hljs-title function_">onPersonChanged1</span>(<span class="hljs-params">val: any, oldVal: any</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val);<br>  &#125;<br><br>  <span class="hljs-comment">// watch: &#123;</span><br>  <span class="hljs-comment">//     &#x27;child&#x27;: [</span><br>  <span class="hljs-comment">//       &#123;</span><br>  <span class="hljs-comment">//         handler: &#x27;onChildChanged&#x27;,</span><br>  <span class="hljs-comment">//         immediate: false,</span><br>  <span class="hljs-comment">//         deep: false</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//     ],</span><br>  <span class="hljs-comment">//     &#x27;person&#x27;: [</span><br>  <span class="hljs-comment">//       &#123;</span><br>  <span class="hljs-comment">//         handler: &#x27;onPersonChanged1&#x27;,</span><br>  <span class="hljs-comment">//         immediate: true,</span><br>  <span class="hljs-comment">//         deep: true</span><br>  <span class="hljs-comment">//       &#125;</span><br>  <span class="hljs-comment">//     ]</span><br>  <span class="hljs-comment">//   &#125;,</span><br>  <span class="hljs-comment">//   methods: &#123;</span><br>  <span class="hljs-comment">//     onChildChanged(val, oldVal) &#123; &#125;,</span><br>  <span class="hljs-comment">//     onPersonChanged1(val, oldVal) &#123; &#125;</span><br>  <span class="hljs-comment">//     onPersonChanged2(val, oldVal) &#123; &#125;</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">// &#125;</span><br><br><br>  @<span class="hljs-title class_">Emit</span>()<br>  public <span class="hljs-title function_">addToCount</span>(<span class="hljs-params">n: number</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> += n;<br>  &#125;<br><br>  @<span class="hljs-title class_">Emit</span>(<span class="hljs-string">&#x27;reset&#x27;</span>)<br>  public <span class="hljs-title function_">resetCount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-number">0</span>;<br>  &#125;<br><br>  @<span class="hljs-title class_">Emit</span>()<br>  public <span class="hljs-title function_">returnValue</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// methods: &#123;</span><br>  <span class="hljs-comment">//   addToCount(n) &#123;</span><br>  <span class="hljs-comment">//     this.count += n</span><br>  <span class="hljs-comment">//     this.$emit(&#x27;add-to-count&#x27;, n)</span><br>  <span class="hljs-comment">//   &#125;,</span><br>  <span class="hljs-comment">//   resetCount() &#123;</span><br>  <span class="hljs-comment">//     this.count = 0</span><br>  <span class="hljs-comment">//     this.$emit(&#x27;reset&#x27;)</span><br>  <span class="hljs-comment">//   &#125;,</span><br>  <span class="hljs-comment">//   returnValue() &#123;</span><br>  <span class="hljs-comment">//     this.$emit(&#x27;return-value&#x27;, 10)</span><br>  <span class="hljs-comment">//   &#125;</span><br>  <span class="hljs-comment">// &#125;</span><br>&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>其中装饰器的官方文档只写了简单的例子，如果需要更深入的使用可以直接利用vscode类型跟踪直接查看其源码查询更多配置</p><p><strong>鼠标移到要查看的类型按住alt健</strong></p><p><img src="/images/vue-typescript/look-type1.png" alt="look-type1"></p><p><strong>从图中可以看到@Prop的参数类型是PropOptions然后追踪到此类型，然后alt+鼠标左键点击查看类型源码</strong></p><p><img src="/images/vue-typescript/look-type2.png" alt="look-type2"></p><p><strong>说明Prop支持3个参数（type：数据类型，required：是否必填，default：默认值，validator：校验），其他装饰器同理可根据此方法查询其配置项</strong></p><h2 id="vuex-class"><a href="#vuex-class" class="headerlink" title="vuex-class"></a>vuex-class</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;button&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;countadd&quot;</span>&gt;</span>添加<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    &#123;&#123;count&#125;&#125;<br>    &#123;&#123;countGetter&#125;&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Vue</span>, <span class="hljs-title class_">Component</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-property-decorator&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">State</span>, <span class="hljs-title class_">Getter</span>, <span class="hljs-title class_">Action</span>, <span class="hljs-title class_">Mutation</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex-class&#x27;</span>;</span><br><span class="language-javascript">@<span class="hljs-title class_">Component</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Vue</span> &#123;</span><br><span class="language-javascript">  @<span class="hljs-title class_">State</span> public count!: number;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  @<span class="hljs-title class_">Action</span> public addCount!: <span class="hljs-function">(<span class="hljs-params">payload: number</span>) =&gt;</span> <span class="hljs-keyword">void</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  @<span class="hljs-title class_">Mutation</span> public <span class="hljs-variable constant_">ADD_COUNT</span>!: <span class="hljs-function">(<span class="hljs-params">payload: string</span>) =&gt;</span> <span class="hljs-keyword">void</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  @<span class="hljs-title class_">Getter</span> public countGetter!: number;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  public <span class="hljs-title function_">countadd</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// this.$store.dispatch(&#x27;addCount&#x27;, 123);</span></span><br><span class="language-javascript">    <span class="hljs-comment">// this.$store.commit(&#x27;ADD_COUNT&#x27;, &#x27;12345&#x27;);</span></span><br><span class="language-javascript">    <span class="hljs-comment">// this.ADD_COUNT(&#x27;1234&#x27;);</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addCount</span>(<span class="hljs-number">123</span>);</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>通过this.$store来触发dispatch或者commit，由于参数是字符串，TS类型无法推断出有哪些mutation，或者action，以及负载参数类型。</p><p>所以使用vuex-class映射出mutation及action，参数就可以定义类型，vscode推断参数类型给予代码提示。</p><p><img src="/images/vue-typescript/vuex-type.png" alt="vuex-type"></p>]]></content>
    
    
    <categories>
      
      <category>三方库使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>各种实现</title>
    <link href="/2019/03/10/%E5%9F%BA%E7%A1%80-pro/"/>
    <url>/2019/03/10/%E5%9F%BA%E7%A1%80-pro/</url>
    
    <content type="html"><![CDATA[<p>模拟实现js原生API</p><span id="more"></span><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>节流是保证在时间间隔内只执行一次，原理是通过是否达到指定的时间间隔</p><p>应用场景： 在页面不断滚动下加载数据； 监听resize，onscroll事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span> (fn, delay) &#123; <br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">let</span> timer;<br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">2</span>)<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(args)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">const</span> remain = delay - (now - startTime)  <span class="hljs-comment">//剩余时间</span><br>    <span class="hljs-built_in">clearTimeout</span>(timer)<br>    <span class="hljs-keyword">if</span>(remain &lt;= <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">//剩余时间小</span><br>      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>      startTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      timer = <span class="hljs-built_in">setTimeout</span>(fn, remain)<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">params</span>)&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>(),params)<br>&#125;<br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-title function_">throttle</span>(a, <span class="hljs-number">1000</span>,<span class="hljs-number">123</span>))<br><br></code></pre></td></tr></table></figure><h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><p>防抖是在规定的计时器时间内触发函数，如果没到规定的时间间隔触发，将会取消并重新计时</p><p>应用场景： sug搜索建议、</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span> (fn, delay) &#123;<br>  <span class="hljs-keyword">let</span> timer <br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span>(timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer)<br>    &#125; <br>    timer = <span class="hljs-built_in">setTimeout</span>(fn, delay)<br>  &#125;<br>  <br>&#125;<br><br><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-title function_">debounce</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()); <span class="hljs-comment">//浏览器窗口变化时 1秒只执行一次</span><br>&#125;, <span class="hljs-number">1000</span>))<br><br></code></pre></td></tr></table></figure><h2 id="实现函数累加fn-1-3-2-3-2"><a href="#实现函数累加fn-1-3-2-3-2" class="headerlink" title="实现函数累加fn(1,3)(2,3)(2)"></a>实现函数累加fn(1,3)(2,3)(2)</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-keyword">let</span> sum = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(argument).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b)<br>  <span class="hljs-keyword">const</span> tmp = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    sum = sum + <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">from</span>(argument).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a,b</span>)=&gt;</span>a+b)<br>    <span class="hljs-keyword">return</span> tmp<br>  &#125;<br>  tmp.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> sum<br>  &#125;<br>  <span class="hljs-keyword">return</span> tmp<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实现一个new"><a href="#实现一个new" class="headerlink" title="实现一个new"></a>实现一个new</h2><p>首先知道js的new关键字做了哪些操作</p><ol><li>创建了新的对象，如果返回的是一个对象则返回该对象否则返回函数本身</li><li>this指向该新对象</li><li>新对象的原型指向构造函数的原型对象</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getNew</span>(<span class="hljs-params">fn</span>)&#123;<br>  <span class="hljs-keyword">var</span> obj = &#123;&#125;<br>  obj.<span class="hljs-property">__proto__</span> = fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    fn.<span class="hljs-title function_">apply</span>(obj, <span class="hljs-variable language_">arguments</span>)<br>    <span class="hljs-keyword">return</span> obj<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">name</span>)&#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span><br>  &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">getNew</span>(test)(<span class="hljs-string">&#x27;张三&#x27;</span>))<br><br></code></pre></td></tr></table></figure><h2 id="实现一个call"><a href="#实现一个call" class="headerlink" title="实现一个call"></a>实现一个call</h2><p>fn.call(newFn, arguments) 调用fn时， 将this指向newFn。本质就是newFn来调用fn</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">newFn</span>) &#123;<br>  newFn.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">let</span> arg = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">let</span> result = newFn.<span class="hljs-title function_">fn</span>(...arg)<br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">newFn</span><br>  <span class="hljs-keyword">return</span> result<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="实现一个bind"><a href="#实现一个bind" class="headerlink" title="实现一个bind"></a>实现一个bind</h2><p>返回一个函数，没有调用。 a.bind({a:1})</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>)&#123;<br>  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span><br>  <span class="hljs-keyword">const</span> arg = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(_this,context)<br>    context.<span class="hljs-property">fn</span> = _this<br>    context.<span class="hljs-title function_">fn</span>(...arg)<br>    <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span><br>    <span class="hljs-comment">// _this.apply(context,arguments)</span><br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><p>垃圾回收跟js执行是同步的，在执行垃圾回收时会暂停js的运行，所以当垃圾回收执行时间过长，那么页面也会卡顿。</p><h2 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a>webpack优化</h2>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Promise</title>
    <link href="/2019/01/08/%E5%9F%BA%E7%A1%80-promise/"/>
    <url>/2019/01/08/%E5%9F%BA%E7%A1%80-promise/</url>
    
    <content type="html"><![CDATA[<p>关于Promise的异常处理</p><span id="more"></span><h2 id="Promise的异常处理"><a href="#Promise的异常处理" class="headerlink" title="Promise的异常处理"></a>Promise的异常处理</h2><p><strong>resolve</strong> 表明通过的决议，<strong>reject</strong> 表明拒绝的决议，如果决议通过，<strong>then</strong> 函数的第一个回调会立即插入 <strong>microtask(微任务)</strong> 队列，<strong>异步立即执行</strong>。</p><blockquote><p>microtask 会被插入到每一个 macrotask微任务 的尾部，所以 microtask 总会优先执行<br>setTimeout setInterval 会插入到 macrotask宏任务 中</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promiseB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;no&#x27;</span>)<br>&#125;)<br>promiseB.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// 永远不会执行</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <span class="hljs-comment">// no</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>如果决议结果是决绝，那么 <strong>then</strong> 函数的第二个回调会立即插入 <strong>microtask</strong> 队列。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promiseF = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok&#x27;</span>)<br>&#125;)<br>promiseF.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error1&#x27;</span>) <span class="hljs-comment">//抛出错误</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// 永远不会执行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;ok1&#x27;</span>) <span class="hljs-comment">// 永远不会执行</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result) <span class="hljs-comment">// 永远不会执行</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error) <span class="hljs-comment">// error1 </span><br>&#125;)<br></code></pre></td></tr></table></figure><p>链式Promise只要出现异常就会被最后一个catch</p><h2 id="Promise-异常捕获"><a href="#Promise-异常捕获" class="headerlink" title="Promise 异常捕获"></a>Promise 异常捕获</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;用户不存在&#x27;</span>)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">fetch</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求处理&#x27;</span>, result) <span class="hljs-comment">// 永远不会执行</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求处理异常&#x27;</span>, error) <span class="hljs-comment">// 请求处理异常 用户不存在</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>抛出的异常也会被catch捕获。</p><h2 id="Promise-无法捕获的异常"><a href="#Promise-无法捕获的异常" class="headerlink" title="Promise 无法捕获的异常"></a>Promise 无法捕获的异常</h2><p>永远不要在 <strong>macrotask</strong> 队列中抛出异常，因为 <strong>macrotask</strong> 队列脱离了运行上下文环境，异常无法被当前作用域捕获。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>             <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;用户不存在&#x27;</span>)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-title function_">fetch</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求处理&#x27;</span>, result) <span class="hljs-comment">// 永远不会执行</span><br>&#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;请求处理异常&#x27;</span>, error) <span class="hljs-comment">// 永远不会执行</span><br>&#125;)<br><br><span class="hljs-comment">// 程序崩溃</span><br><span class="hljs-comment">// Uncaught Error: 用户不存在</span><br></code></pre></td></tr></table></figure><h2 id="手写Promise"><a href="#手写Promise" class="headerlink" title="手写Promise"></a>手写Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-comment">//正常用法：</span><br><span class="hljs-keyword">const</span> test = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>( <span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;构造函数调用&#x27;</span>)<br>    <span class="hljs-keyword">let</span> height , width;<br>    <span class="hljs-keyword">let</span> image = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>();<br>    image.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;https://sf6-scmcdn2-tos.pstatp.com/xitu_juejin_web/img/logo.a7995ad.svg&#x27;</span>;<br>    image.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>        width = <span class="hljs-variable language_">this</span>.<span class="hljs-property">width</span><br>        height = <span class="hljs-variable language_">this</span>.<span class="hljs-property">height</span><br>        <span class="hljs-title function_">resolve</span>(&#123;width,height&#125;)<br>    &#125;;<br>&#125;)<br><br>test.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res)<br>&#125;)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>)&#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span> = [];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span> = [];<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">resolve</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>),<span class="hljs-variable language_">this</span>.<span class="hljs-property">reject</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>))<br>    &#125;<br>    <br>    <span class="hljs-title function_">resolve</span>(<span class="hljs-params">params</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> == <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">staus</span> = <span class="hljs-string">&#x27;success&#x27;</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = params<br><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">reject</span>(<span class="hljs-params">error</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-string">&#x27;error&#x27;</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = error<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">cb</span> =&gt;</span> <span class="hljs-title function_">cb</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>))<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-title function_">then</span>(<span class="hljs-params">onSuccess,onError</span>)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;pending&#x27;</span>)&#123;<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">push</span>(onSuccess);<br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onError)<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;success&#x27;</span>)&#123;<br>            <span class="hljs-title function_">onSuccess</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-string">&#x27;error&#x27;</span>)&#123;<br>            <span class="hljs-title function_">onError</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>        &#125;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>promise的race和all</p><ul><li>all接收一组异步任务作为参数，并行执行任务，所有结果都返回后执行回调</li><li>race接收一组参数作为异步任务，并行执行，但是只会取第一个完成的任务的结果，其它任务也会执行，但是返回的结果不进入回调</li><li>all和race传入的数组中如果有会抛出异常的异步任务，只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</li></ul><p><strong>注意点</strong></p><p>promise的链式调用过程中，then&#x2F;catch&#x2F;finally都会返回一个promise，加入微任务队列。</p><p>finally回调没有参数，无法知道promise是成功还是失败，默认返回上一个promise值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><br><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br>  &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;then&#x27;</span>, res) <span class="hljs-comment">// then, 2</span><br>  &#125;)<br><br></code></pre></td></tr></table></figure><h2 id="async-await"><a href="#async-await" class="headerlink" title="async await"></a>async await</h2><ul><li>await会阻塞后面代码的运行，因为await的是一个promise对象，需要等待promise的resolve回调后才会继续执行</li><li>async函数中抛出异常（error）、错误（reject），会终止错误结果，不会继续执行，如果想在错误的情况下继续执行可以使用try catch来捕获</li></ul>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>markdown 语法</title>
    <link href="/2018/06/12/%E5%9F%BA%E7%A1%80-markdown/"/>
    <url>/2018/06/12/%E5%9F%BA%E7%A1%80-markdown/</url>
    
    <content type="html"><![CDATA[<p>记录一般markdown语法</p><span id="more"></span><p><a href="https://hexo.io/">Hexo</a> 文字链接</p><p><em>这里是文字</em> 斜体<br><strong>这里是文字</strong> 加粗<br><em><strong>这里是文字</strong></em> 斜体加粗<br><del>这里是文字</del> 删除线</p><p><a href="https://github.com/gd2016">https://github.com/gd2016</a></p><p><img src="/images/favicon-32x32-next.png" alt="test" title="test"> 图片链接</p><hr><p>分割线</p><p><code>test.map(item=&gt;&#123;   console.log(item) &#125;) 单行代码块</code> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">test.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">item</span>=&gt;</span>&#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item)<br>&#125;)<br>代码块<br></code></pre></td></tr></table></figure><h2 id="子标题"><a href="#子标题" class="headerlink" title="子标题"></a>子标题</h2><blockquote><p>这是一段引用文字</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">&gt;<span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure></blockquote><ul><li>无序列表</li><li>无序列表</li><li>无序列表</li></ul><ol><li>有序列表1<br><code>alert(1)</code></li><li>有序列表2<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">alert</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure></li><li>有序列表3</li></ol><table><thead><tr><th align="left">表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td align="left">元素</td><td align="center">元素</td><td align="right">元素</td></tr><tr><td align="left">元素</td><td align="center">元素</td><td align="right">元素</td></tr><tr><td align="left">元素</td><td align="center">元素</td><td align="right">元素</td></tr></tbody></table><p><font color='red'>字体颜色</font></p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>scopes</title>
    <link href="/2018/05/12/%E5%9F%BA%E7%A1%80-scopes/"/>
    <url>/2018/05/12/%E5%9F%BA%E7%A1%80-scopes/</url>
    
    <content type="html"><![CDATA[<p>JavaScript 闭包、垃圾回收、[[scopes]]属性</p><span id="more"></span><p>静态作用域链和动态作用域链的区别<br>为什么会有闭包<br>闭包什么时候创建的<br>[[scopes]] 属性是什么<br>闭包保存什么内容<br>闭包存储在哪<br>为什么 eval 性能不好<br>eval 什么情况下会创建闭包</p><blockquote><p>参考： <a href="https://juejin.cn/post/6957913856488243237">https://juejin.cn/post/6957913856488243237</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于bfc</title>
    <link href="/2018/03/04/%E5%9F%BA%E7%A1%80-bfc/"/>
    <url>/2018/03/04/%E5%9F%BA%E7%A1%80-bfc/</url>
    
    <content type="html"><![CDATA[<p>探探BFC</p><span id="more"></span><h2 id="什么是BFC"><a href="#什么是BFC" class="headerlink" title="什么是BFC"></a>什么是BFC</h2><blockquote><p>Block formatting context 独立的渲染区域，块级元素格式化上下文，决定了内容的布局方式与区域外部没有任何关系<br>一般通过修改元素的css，该元素对内部元素和外部元素表现出的一些特性 就称为BFC</p></blockquote><h2 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h2><ol><li>float的值不为none</li><li>overflow值不为visiable</li><li>display的值为inline-block、table-cell、table-caption</li><li>position的值为absolute或fixed</li></ol><h2 id="普通文档流的布局规则"><a href="#普通文档流的布局规则" class="headerlink" title="普通文档流的布局规则"></a>普通文档流的布局规则</h2><ol><li><p>浮动的元素是不会被父级计算高度</p></li><li><p>非浮动元素会覆盖浮动元素的位置</p></li><li><p>margin会传递给父级</p></li><li><p>两个相邻元素上下margin会重叠</p></li></ol><h1 id="bfc的布局规则"><a href="#bfc的布局规则" class="headerlink" title="bfc的布局规则"></a>bfc的布局规则</h1><ol><li>浮动的元素会被计算高度，如果父级设置overflow:hidden,那么就不会高度坍塌，父级也会存在高度 （父级触发BFC）</li><li>非浮动元素不会覆盖浮动元素位置（非浮动元素触发了BFC）</li><li>margin不会传递给父级（父级触发BFC）</li><li>两个相邻元素上下margin不会重叠（给其中一个元素增加一个父级，然后让他的父级触发BFC）</li></ol><h1 id="bfc的应用"><a href="#bfc的应用" class="headerlink" title="bfc的应用"></a>bfc的应用</h1><p>清除浮动：父元素设置overflow: hidden 触发BFC实现清除浮动，防止父元素高度塌陷，后面的元素被覆盖，实现文字环绕等等。<br>消除相邻元素垂直方向的边距重叠：第二个子元素套一层，并设置overflow: hidden，构建BFC使其不影响外部元素。<br>消除父子元素边距重叠，父元素设置overflow: hidden</p>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>详细说说输入URL到页面出现发生了什么</title>
    <link href="/2008/12/20/%E5%9F%BA%E7%A1%80-url/"/>
    <url>/2008/12/20/%E5%9F%BA%E7%A1%80-url/</url>
    
    <content type="html"><![CDATA[<p>记录下大概的流程</p><span id="more"></span><h2 id="DNS解析域名的实际IP地址"><a href="#DNS解析域名的实际IP地址" class="headerlink" title="DNS解析域名的实际IP地址"></a>DNS解析域名的实际IP地址</h2><p>从浏览器 -&gt; 系统(hosts) -&gt; 路由器 -&gt; ISP 的缓存中寻找是否有网址对应的IP地址，找到直接下一步，没有则向 ISP 或者公共的域名解析服务发起 DNS 查找请求。查找的过程是递归查询的过程。 这个ISP就是互联网服务的提供商，面向用户提供的互联网接入等服务</p><h2 id="检查浏览器的缓存"><a href="#检查浏览器的缓存" class="headerlink" title="检查浏览器的缓存"></a>检查浏览器的缓存</h2><p>根据cache-control和Expires检查是否命中强缓存，命中直接取内存或者本地磁盘的html，没有命中强缓存 进行下一步建立连接 根据响应判断是否命中协商缓存</p><h2 id="与-WEB-服务器建立-TCP-连接。"><a href="#与-WEB-服务器建立-TCP-连接。" class="headerlink" title="与 WEB 服务器建立 TCP 连接。"></a>与 WEB 服务器建立 TCP 连接。</h2><p>三次握手</p><ol><li>客户端发送SYN报文连接请求，确定服务器是否能连接，此时状态置为SYN_SEND</li><li>服务器如果能够连接，返回SYN+ACK报文给客户端，状态置为SYN_RECV</li><li>客户端收到服务器的SYN+ACK，再向服务器发送ACK确认。 两端状态都置为ESTABLISHED状态，建立连接，开始传送数据</li></ol><h2 id="如果协议是https则加密"><a href="#如果协议是https则加密" class="headerlink" title="如果协议是https则加密"></a>如果协议是https则加密</h2><p>HTTPS &#x3D; HTTP + 加密 + 认证 + 完整性保护</p><h3 id="证书是什么"><a href="#证书是什么" class="headerlink" title="证书是什么"></a>证书是什么</h3><p>证书含有一对公钥和私钥（这就是非对称加密），可以想像成钥匙和一个锁，只有服务器有这把钥匙，服务器把锁头给到客户端， 客户端把信息都放在锁头里面，然后发给服务器，因为只有服务器有这把钥匙所以也就只有服务器能解密客户端传过来的信息。</p><ol><li>申请CA证书，并安装在服务器上（一个文件，配置nginx支持监听443端口开启ssl并设置证书路径）</li><li>浏览器发请求</li><li>服务器发送带有公钥的证书</li><li>浏览器解析证书<ol><li>验证合法性，不合法会提示证书不受信任，合法则显示一个锁头</li><li>合法后浏览器生成随时数的密钥，并用证书提供的公钥加密（也就是把消息放到锁头里面，以后的通信都通过这个随机数来进行加解密）</li></ol></li><li>服务器解析消息，用跟证书公钥配对的私钥（也就是钥匙）将客户端发过来的消息解密并得到随机数，然后把内容通过随机数对称加密，发送给客户端</li><li>客户端用生成的随机数（私钥）解密传过来的信息。</li></ol><h2 id="浏览器发送请求获取html"><a href="#浏览器发送请求获取html" class="headerlink" title="浏览器发送请求获取html"></a>浏览器发送请求获取html</h2><p>浏览器向获取到的服务器ip地址发送get请求获取到html</p><h2 id="服务器响应html"><a href="#服务器响应html" class="headerlink" title="服务器响应html"></a>服务器响应html</h2><p>服务器可能是cdn</p><h2 id="浏览器解析html"><a href="#浏览器解析html" class="headerlink" title="浏览器解析html"></a>浏览器解析html</h2><h2 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h2><h2 id="浏览器执行js脚本"><a href="#浏览器执行js脚本" class="headerlink" title="浏览器执行js脚本"></a>浏览器执行js脚本</h2><h2 id="浏览器发网络请求"><a href="#浏览器发网络请求" class="headerlink" title="浏览器发网络请求"></a>浏览器发网络请求</h2>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>node相关</title>
    <link href="/2008/05/12/%E5%9F%BA%E7%A1%80-node/"/>
    <url>/2008/05/12/%E5%9F%BA%E7%A1%80-node/</url>
    
    <content type="html"><![CDATA[<p>理解node</p><span id="more"></span><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><p>进程是线程的容器，资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。</p><h3 id="什么是单线程"><a href="#什么是单线程" class="headerlink" title="什么是单线程"></a>什么是单线程</h3><p>一个进程只开一个线程那么就是单线程</p><blockquote><p><a href="https://juejin.cn/post/6844903908385488903#heading-9">https://juejin.cn/post/6844903908385488903#heading-9</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
